<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>麦客园</title><atom:link href="https://mikecyc.github.io/feed.xml" rel="self" type="application/rss+xml"></atom:link><link>https://mikecyc.github.io</link><description>集基督信仰，IT技术，生活的家园，分享生活中的点点滴滴。关注Web前端, iOS, Android, 网络技术, Linux, 开源硬件等。</description><pubDate>Thu, 30 Jun 2016 08:00:00 +0800</pubDate><generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator><language>en</language><item><title>成为自由职业者，很难吗？</title><link>https://mikecyc.github.io/articles/as-a-freelancer/</link><pubDate>Thu, 30 Jun 2016 08:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/as-a-freelancer/</guid><author></author><description>&lt;p&gt;很多人都想开咖啡馆，我一度奇怪为什么咖啡馆会让那么多人心心念念？后来发现，咖啡馆、小餐馆、奶茶店、小客栈、淘宝小店……这些梦想指数高的关键词，它们有一些共同的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能够获得一份收入&lt;/li&gt;
&lt;li&gt;入门较简单，不需花费过多成本和精力&lt;/li&gt;
&lt;li&gt;自己说了算，不牵扯太多团队合作&lt;/li&gt;
&lt;li&gt;美美哒&lt;/li&gt;
&lt;li&gt;面向流动人群&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;想开这些店的人，潜台词是：&lt;strong&gt;我想过自由的生活，有点钱，够日常支出就好；有点闲，能慢下来，享受过程的美好；有趣，能认识更多朋友。&lt;/strong&gt;&lt;/p&gt;
&lt;!-- MORE --&gt;
&lt;p&gt;维持平衡就好，有钱但忙到死，有趣但穷到哭，有闲但无聊得要命，都不算一个好状态。如果没钱没时间还无聊，光是想想都生不如死呢。&lt;/p&gt;
&lt;p&gt;那么问题来了，如何才能达到平衡的状态呢？相当一部分人会说：“我很想辞职，不想被老板骂，不想挤高峰期的地铁，不想周末加班还没有加班费，不想一年只有7天假期想请假出去旅游的时候还要看别人的脸色，但我不知道辞职以后干什么？”“我很想自己做点什么，但想了好几年，也没有勇气真的放弃现在的生活。”&lt;/p&gt;
&lt;p&gt;自由职业者，首先要职业，然后才自由。&lt;/p&gt;
&lt;p&gt;单枪匹马出来混，总得有个技能防身（资源人脉开挂，有雄厚经济基础的自动略过），一技之长是提供个人价值并因此获得回报的前提。不具备职业性，辞职后即使拥有了大把时间，也感受不到自由，因为时间都花在焦虑上了，焦虑生意没法走上正轨，焦虑没有客源，焦虑没有稳定的现金流，有的是让你大把掉头发的麻烦等着，哪还有悠然自得的心情。&lt;/p&gt;
&lt;p&gt;大多数人在第一步就卡住了，“可是我什么都不会啊？”&lt;/p&gt;
&lt;p&gt;能理直气壮说出这句话的人，应该写封感谢信去给老板，感谢老板雇佣了你，给了口饭吃，什么都不会了，还要什么自行车（不对，要什么假期，要什么不坐班，要什么有趣还美美的）？！&lt;/p&gt;
&lt;p&gt;不要找借口，说什么我没本事，没机会，没平台，你之所以不会，就是因为懒。&lt;/p&gt;
&lt;p&gt;怎么拥有一技之长？&lt;/p&gt;
&lt;p&gt;首先记住——辞职前不会干的事情，辞职后大多也不会干。&lt;/p&gt;
&lt;p&gt;不要想说等我辞职后，再去学个什么什么，不管工作有多忙，学一项技能的时间一定是可以挤出来的。&lt;/p&gt;
&lt;p&gt;在有工作保障的时候，就应该开始为自由生活做内测，是的，自由职业和其它创业一样，需要反复摸索实验失败爬起后才能趟出一条阳光大道。辞职以前，试着做这些事情。&lt;/p&gt;
&lt;h2 id=&quot;1-&quot;&gt;1、花钱&lt;/h2&gt;
&lt;p&gt;趁有钱可花的时候，学会怎么花钱。免费的东西是最贵的，它用很差的质量占用了你的带宽，抢占了你享受好东西的时间。不要吝啬花钱，网上固然有看不完的免费资料、公开课、论坛讨论，但基本上停留在入门级，想要深入下去，不妨花一点钱，去买专业书籍，请专业人士培训，去专业的店铺体验，花钱买别人长期累积的专业和视野，买别人已经实验论证过的正确方法，是很划得来的买卖。在掌握正确方法的情况下，学会一项谋生技能，1-2年就足够了。&lt;/p&gt;
&lt;h2 id=&quot;2-&quot;&gt;2、花精力&lt;/h2&gt;
&lt;p&gt;就算是个自由职业者，你也不是一个人在战斗，前期累积的资源、人脉、平台越多，后期才越容易产生连接并实现合作。去认识与技能相关的群体，加入他们。就职的公司能够提供平台当然最好，如果目前的工作和将来自由职业的方向没有一点关系，那也不要紧，这个时代提供了大量由兴趣连接的社交工具，花点时间，保持开放的心态，坚持在正确的社交平台上发出自己的声音，或许会有意想不到的收获。你是最常接触的五个朋友的平均值，如果五个最好朋友都是安分守己的上班族，那么你自己成为一个安静美男子/少女的几率是多大呢？&lt;/p&gt;
&lt;h2 id=&quot;3-&quot;&gt;3、花时间&lt;/h2&gt;
&lt;p&gt;热情有，方法有，跨出了第一步，更多的人会跌倒在第二步，热血地学习了一段时间后偃旗息鼓，虎头蛇尾最后不了了之。所有事情都是“略懂略懂”，真的要成为事业那还且着呢。这个时候，最重要的是养成一个好习惯，形成一个新习惯起码需要连续坚持21天，保持下去则需要坚持100天，达到牛逼级别需要花掉10000小时，想想你为此投入了多少时间？请不要再说“我就是什么都不会”“我没有这种本事”之类的话了。你不会，不就是没有花够别人花的时间吗？&lt;/p&gt;
&lt;h2 id=&quot;4-&quot;&gt;4、心态调整&lt;/h2&gt;
&lt;p&gt;那些说“没有勇气放弃现在生活”的人，要解决的不光是能力问题，还有心态问题。害怕挑战、不敢放弃、逃避选择，说白了，不是真的想要改变，只是想什么好处都占着。改变都有风险，但一成不变的风险更大。&lt;/p&gt;
&lt;p&gt;学会放弃，一无所有的时候还好，年纪越大越不容易做到。但年纪大并不是借口。种一棵树，最好的时间是10年前，其次是现在。没有什么时候是最好的开始时机，虽然90后年纪轻，可是60后心机重啊～&lt;/p&gt;
&lt;p&gt;学会接受挑战，自由职业者如同单口相声演员，出场以后一两个包袱没抖响，心情就开始沮丧了，既然选择站在舞台上，有没有观众反馈，都要保持high high的状态直到谢幕为止。要相信，所有的努力都不会白费，重要的是坚持做下去。而在职时提前演练，抱着失败了也没关系的念头，在心态上会平和很多。&lt;/p&gt;
&lt;h2 id=&quot;5-&quot;&gt;5、保持敏锐&lt;/h2&gt;
&lt;p&gt;自由职业需要保持紧张感，而上班久了，习惯寻求安全感，反应速度慢，自主性差，靠别人推着才会走一走。刚辞职的时候，我每天必须打开outlook看好几遍（以前上班，一天要刷几十遍邮箱，不断处理来自四面八方的工作单），脱离了邮件，居然不知道自己该干什么好。不能自主驱动从始自终做一个完整的项目，就只能做一颗流水线上的螺丝钉，成为抽几巴掌才会旋转的陀螺。简单说，首先要成为一台发动机，把电源动力掌握在自己手里才行。&lt;/p&gt;
&lt;p&gt;说了这么多，为什么有时候上班给人感觉那么不好，因为你还没有找到一个完整的自己，这个完整的你，可以实现自循环，不因职业岗位领导同事的改变而改变自身属性，没有自由职业意识的人，觉得工作在为别人打工，自己无非是挣钱糊口。当你把重心放在自己身上时，才会感到无论做什么事都是别人在为自己打工，工作是为自己积攒资金、人脉、资源和方法论，帮助建立一个完善的自品牌。&lt;/p&gt;
&lt;p&gt;大多数人把时间刷微博微信看韩剧逛淘宝买包包花掉了，因为他们并不知道如果不这样，还能为自己做些什么，才能抚慰日日焦躁而疲惫不堪的心。如果想摆脱现有困境，成为一个工作生活平衡的自由职业者，就要先去找到自己，想明白“我是谁”“我想做什么”“我该怎么做”的问题。&lt;/p&gt;
&lt;p&gt;有时间不代表有自由，工作很忙也不代表没有自由，无论什么时候，找到自己，才会自由。&lt;/p&gt;
</description></item><item><title>CSS强制不换行|自动换行|强制换行</title><link>https://mikecyc.github.io/articles/css-word-break-or-not/</link><pubDate>Mon, 13 Jun 2016 08:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/css-word-break-or-not/</guid><author></author><description>&lt;p&gt;经常会用到CSS控制文字要怎样换行的样式，每次用的时候都不记得，顾在这里备忘。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;强制不换行&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;lang-CSS&quot;&gt;&lt;span class=&quot;tag&quot;&gt;white-space&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:nowrap&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;自动换行&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;lang-CSS&quot;&gt;&lt;span class=&quot;tag&quot;&gt;word-wrap&lt;/span&gt;: &lt;span class=&quot;tag&quot;&gt;break-word&lt;/span&gt;;
&lt;span class=&quot;tag&quot;&gt;word-break&lt;/span&gt;: &lt;span class=&quot;tag&quot;&gt;normal&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;强制英文单词断行&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;lang-CSS&quot;&gt;&lt;span class=&quot;tag&quot;&gt;word-break&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:break-all&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
</description></item><item><title>提高网站访问速度的十个技巧</title><link>https://mikecyc.github.io/articles/10method-sped-your-site/</link><pubDate>Sun, 12 Jun 2016 08:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/10method-sped-your-site/</guid><author></author><description>&lt;p&gt;非常经典的一篇文章，已经有10年的历史了，到现在还是非常实用，找不出原出处，贴上来备忘。&lt;/p&gt;
&lt;p&gt;网站的访问速度和性能对用户体验来说是非常重要的。如果你的网站访问非常的慢，你不仅会失去用户，而且更可怕的是你会失去潜在的客户。像Google这样的互联网巨头也会把网站访问速度作为排名的一个参数。因此当你需要优化网站速度时，你需要考虑方方面面，每个毫秒。这里对改进网站性能提出一些基础和普遍的建议。&lt;/p&gt;
&lt;!-- MORE --&gt;
&lt;h1 id=&quot;1-&quot;&gt;1、如果可能的话，延迟加载一些内容&lt;/h1&gt;
&lt;p&gt;可以使用Ajax来按需加载部分内容。比如一个相册，可以在用户浏览页面时先出缩略图，当用户点击了，然后异步请求原图并展示，这样用户如果只需要看几张图片，就不需要等待所有图片都加载下来。这种开发模式叫做延迟加载。
Ajax/Web开发类库如jQuery，Prototype，与及MooTools可以使得延迟加载更容易实现。&lt;/p&gt;
&lt;h1 id=&quot;2-js-css-&quot;&gt;2、使用外部JS和CSS文件&lt;/h1&gt;
&lt;p&gt;当用户第一次加载网页时，浏览器会缓存住外部的CSS和JavaScript文件，所以将javascript和CSS放到外部文件比内联的会好。
使用内联CSS还会增加网页的渲染时间，让所有样式都定义在你的主CSS文件中使得浏览器渲染页面时少做一些工作，因为它一开始就知道所有需要应用的样式规则。另外使用外部javascript和css文件也有助于维护代码。&lt;/p&gt;
&lt;h1 id=&quot;3-&quot;&gt;3、使用缓存系统&lt;/h1&gt;
&lt;p&gt;如果你发现网站总是连接数据库来查询产生出同样的结果，可能就需要使用缓存系统了。使用缓存的话，只需要生成一次特定的内容而不需要用户每次访问的时候都去生成。缓存系统也会根据配置周期性的刷新缓存。你可以生成静态HTML页，以减小服务器脚本执行的开消，或者使用数据库和服务端脚本缓存系统，比如PHP的加速器，memcached等。&lt;/p&gt;
&lt;h1 id=&quot;4-html-&quot;&gt;4、避免在html中改变图片大小&lt;/h1&gt;
&lt;p&gt;如果一张图片原本是1280900px的，但是你需要它显示为400280px的，你应该用图片编辑器，如Photoshop来改变它的大小，而不是使用HTML的width和height属性。&lt;/p&gt;
&lt;h1 id=&quot;5-&quot;&gt;5、不要使用图片来展示文字&lt;/h1&gt;
&lt;p&gt;图片中的文字不但对用户不友好（无法复制等），对SEO也没有好处，而且使用图片来显示文字会增加页面加载时间。如果你需要在网站中使用很多自定义的字体，可以考虑使用CSS的@font-face特性去更有效率地展现特定字体。&lt;/p&gt;
&lt;h1 id=&quot;6-&quot;&gt;6、使用正确的文件格式来优化图片大小&lt;/h1&gt;
&lt;p&gt;通过选择正确的力图片格式，你可以在不损失图片质量的情况下优化图片大小。例如，除非你需要PNG提供的图片透明，否则JPG一般来说可以在较小的文件情况下逼真地显示图片。&lt;/p&gt;
&lt;h1 id=&quot;7-&quot;&gt;7、优化写代码的方式&lt;/h1&gt;
&lt;p&gt;查看你的源代码，看看是否所有标签都是需要的，或是可不可以用CSS来代替。有效的书写代码不但减小HTML和CSS文件的大小，也能方便维护。&lt;/p&gt;
&lt;h1 id=&quot;8-javascript&quot;&gt;8、在文档的最后加载javascript&lt;/h1&gt;
&lt;p&gt;所有scripts都在页面最后加载会比一开始就加载好，它可以让浏览器在加载javascript前渲染所有东西。浏览器在javascript下载完之前阻塞下面的内容的加载。如果可以的话，尽量将javascript放在紧挨着body结束标签的地方。&lt;/p&gt;
&lt;h1 id=&quot;9-content-delivery-network-cdn-&quot;&gt;9、使用内容分发网络（Content Delivery Network，CDN）&lt;/h1&gt;
&lt;p&gt;网站的速度和用户相对于服务器的位置有很大的关系。将内容分发到不同的地理位置可能可以缓解这个问题。使用CDN可能会增加费用，但是收益也是很明显的。&lt;/p&gt;
&lt;h1 id=&quot;10-&quot;&gt;10、优化网页缓存&lt;/h1&gt;
&lt;p&gt;既然使用了缓存系统，你应该使用尽可能多的缓存技术。网页缓存是浏览器端对文件做的缓存，然后供用户之后的访问。浏览器可以缓存的内容包括CSS文件，javascript文件和图片。&lt;/p&gt;
&lt;p&gt;除了把多个页面都用到的CSS和javascript放在一个外部文件以外，还有很多方法来保证文件缓存起到最大的作用。例如你可以设置HTTP响应头为Expires和Last-Modified来减少用户重新访问你网站时特定文件重新下载的次数。&lt;/p&gt;
</description></item><item><title>深入理解Node.js中的垃圾回收和内存泄漏的捕获</title><link>https://mikecyc.github.io/articles/understanding-nodejs-gc/</link><pubDate>Tue, 17 May 2016 00:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/understanding-nodejs-gc/</guid><author></author><description>&lt;p&gt;对于Node.js而言，通常被抱怨最多的是它的性能问题。当然这并不意味着Node.js在性能方面就比其他技术表现的都更差， 因此开发者有必要清晰的理解Node.js是具体如何工作的的。由于这个技术有一个非常扁平的学习曲线， 如果要跟踪Node.js的运行，通常都比较复杂，因此你需要提前理解它的运行机制，从而避免可能存在的性能损失。一旦出现了问题， 你需要尽快的定位它并进行修复。本文主要介绍了如何管理Node.js应用的内存，以及如何向下追踪与内存相关的问题。&lt;/p&gt;
&lt;h2 id=&quot;statement&quot;&gt;Statement&lt;/h2&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://apmblog.dynatrace.com/2015/11/04/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/&quot;&gt;http://apmblog.dynatrace.com/2015/11/04/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;node-js-&quot;&gt;Node.js内存管理&lt;/h2&gt;
&lt;p&gt;不同于PHP这样的平台，Node.js应用是一个一直运行的进程。虽然这种机制有很多的优点，例如在配置数据库连接信息时， 只需要建立一次连接，便可以让所有的请求进行复用该连接信息，但不幸的是，这种机制也存在缺陷。 但是，首先我们还是来了解一些Node.js基本知识。&lt;/p&gt;
&lt;h2 id=&quot;node-js-javascript-v8-c-&quot;&gt;Node.js是一个由JavaScript V8引擎控制的C++程序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/v8/&quot;&gt;Google V8&lt;/a&gt;是一个由Google开发的JavaScript引擎，但它也可以脱离浏览器被单独使用。 这使得它能够完美的契合Node.js，实际上V8也是Node.js平台中唯一能够理解JavaScript的部分。 V8会将JavaScript代码向下编译为本地代码（native code），然后执行它。在执行期间，V8会按需进行内存的分配和释放。 这意味着，如果我们在谈论Node.js的内存管理问题，也就是在说V8的内存管理问题。&lt;/p&gt;
&lt;p&gt;你可以参考&lt;a href=&quot;https://developers.google.com/v8/get_started&quot;&gt;这个链接&lt;/a&gt;来了解如何从C++的角度使用V8。&lt;/p&gt;
&lt;h2 id=&quot;v8-&quot;&gt;V8的内存管理模式&lt;/h2&gt;
&lt;p&gt;一个运行的程序通常是通过在内存中分配一部分空间来表示的。这部分空间被称为驻留集（Resident Set）。 V8的内存管理模式有点类似于Java虚拟机（JVM），它会将内存进行分段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码 Code：实际被执行的代码&lt;/li&gt;
&lt;li&gt;栈 Stack：包括所有的携带指针引用堆上对象的值类型（原始类型，例如整型和布尔），以及定义程序控制流的指针。&lt;/li&gt;
&lt;li&gt;堆 Heap：用于保存引用类型（包括对象、字符串和闭包）的内存段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-v8-memory-scheme.png&quot; alt=&quot;v8 memory scheme&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Node.js中，当前的内存使用情况可以轻松的使用&lt;code&gt;process.memoryUsage()&lt;/code&gt;进行查询， 实例程序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; util = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'util'&lt;/span&gt;);
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(util.inspect(process.memoryUsage()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将会在控制台产生如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-json&quot;&gt;{ 
    rss: 4935680,
    heapTotal: 1826816,
    heapUsed: 650472
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;process.memoryUsage()&lt;/code&gt;函数返回的对象包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常驻集的大小 - rss&lt;/li&gt;
&lt;li&gt;堆的总值 - heapTotal&lt;/li&gt;
&lt;li&gt;实际使用的堆 - heapUsed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以利用这个函数来记录不同时间的内存使用情况，并利用这些数据绘制成一张图从而更清晰的展示V8是如何处理内存的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-v8-memory-usage.png&quot; alt=&quot;node.js memory usage&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中最顶端的橙色线条为RSS（驻留集大小），接下来红色线条表示堆的总值，表现的最为不稳定的部分是黄色线条， 它所表示的是已使用的堆的大小，虽然线条不停的抖动，但总是维持在一定的边界值内保持一个稳定中位数。 分配和回收堆内存的机被称为垃圾回收（Garbage Collection）。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;垃圾回收&lt;/h2&gt;
&lt;p&gt;每个需要消耗内存的程序都需要某种机制来预约和释放内存空间。在C和C++程序中，程序可以通过&lt;code&gt;malloc()&lt;/code&gt;和&lt;code&gt;free()&lt;/code&gt; 这两个函数来申请和释放内存。我们发现，这需要由程序员负责释放不再使用的堆内存空间。如果一个程序所分配的内存不再使用了， 却没有被及时释放的话，那么逐渐累积会导致程序对堆空间的消耗越来越大，直至耗尽整个堆空间，此时会导致程序崩溃。 通常我们称这种情况为内存泄漏（memory leak）。&lt;/p&gt;
&lt;p&gt;前面我们已经了解到，Node.js的JavaScript代码会通过V8编译为本地代码（Native Code）。 显然最终的原始数据结构已经和最初的表示没有太多的关系了，它完全由V8来进行管理。这说明， 在JavaScript中，我们并不能主动的进行内存的分配和回收操作。V8使用了著名的被称为“垃圾回收”的机制来自动解决这个问题。&lt;/p&gt;
&lt;p&gt;垃圾回收背后的理论非常的简单：如果内存段不再被其他地方引用，我们便可以假设它已经不再被使用，因此，就可以释放这片内存段。 然而， 检索和维护这些信息是非常复杂的，因为这可能会涉及到引用之间的相互链接，从而形成一个复杂的图结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-memory-heap-graph.png&quot; alt=&quot;A Heap Graph&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上面的堆图中，如果红色的对象不再有引用指向它的话，那么该对象就可以被丢弃（释放内存）。&lt;/p&gt;
&lt;p&gt;垃圾回收是个代价非常高的进程，因为它会中断程序在执行，从而影响程序的性能。为了补救这种情况，V8使用了两种类型的垃圾回收：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scavenge（提取），速度快但不彻底&lt;/li&gt;
&lt;li&gt;Mark-Sweep（标记-清除），相对慢一点，但是可以回收所有未被引用的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以通过&lt;a href=&quot;http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection&quot;&gt;这篇博文&lt;/a&gt;深入的了解更多关于V8垃圾回收的内容。&lt;/p&gt;
&lt;p&gt;重新回顾我们利用&lt;code&gt;process.memoryUsage()&lt;/code&gt;方法收集到的数据，我们可以很简单的就识别出不同的垃圾回收类型： 成锯齿状（saw-tooth pattern）是由Scavenge创建的，而出现向下跳跃的则是由Mark-Sweep操作产生的。&lt;/p&gt;
&lt;p&gt;通过使用原生模块&lt;code&gt;node-gc-profiler&lt;/code&gt;，我们可以收集更多关于垃圾回收的信息。 该模块会订阅由V8触发的所有垃圾回收事件，并将它们暴露给JavaScript。&lt;/p&gt;
&lt;p&gt;返回的对象表示了垃圾回收的类型和持续时间。再一次的，我们可以轻松的利用可视化图形来更好的理解它是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-duraction-and-frequency-of-gc-runs.png&quot; alt=&quot;duration and ferquency of gc runs&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现Scavenge Compact运行的比Mark Sweep更为频繁。根据应用的复杂程度这可能会存在一定的变化。 有意思的是，上面的图形也展现了频繁却非常短的Mark-Sweep运行状况，这也跟运行的函数有关。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;如果出了故障&lt;/h2&gt;
&lt;p&gt;既然有垃圾回收器来负责内存清理，那么为什么我们还需要关心这个呢？事实上，这仍然会有可能发生内存泄漏， 你的日志记录可能会记录这些信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-memory-leak.png&quot; alt=&quot;exception caused by memory leak&quot;&gt;&lt;/p&gt;
&lt;p&gt;当内存泄漏出现的时候，内存可能会出现堆积的情况，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-memory-leak-in-progress.png&quot; alt=&quot;memory leak in progress&quot;&gt;&lt;/p&gt;
&lt;p&gt;垃圾回收（GC）机制会尽可能的回收内存，但是每次运行GC都会导致一定的损耗。我们发现在上图中，堆内存的使用处于一个不断攀升的过程， 这通常意味着内存泄漏的发生。使用这些信息，我们能够较为方便的判断是否出现了内存泄漏， 下面我们进一步的探索如何在内存泄漏发生的是去向下最终问题的源头。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;问题追踪和解决&lt;/h2&gt;
&lt;p&gt;有些泄漏的发生是显而易见的，例如将数据存储在全局变量中，例如将每次访问用户的IP信息都存放在一个数组中。 而有些问题则是不易察觉的，例如著名的&lt;a href=&quot;https://www.joyent.com/blog/walmart-node-js-memory-leak&quot;&gt;沃尔玛内存泄漏&lt;/a&gt;事件, 它是由于Node.js核心代码中一个非常细微的声明缺失导致的，这可能需要花费数周的事件才能追踪到。&lt;/p&gt;
&lt;p&gt;在这里我并不会覆盖核心的代码错误。而是来看一个难以追踪的内存泄漏案例，通过这个例子能够让你在自己的JavaScript代码中定位错误， 这个例子来源于&lt;a href=&quot;http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak&quot;&gt;Meteor的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-leak-example.png&quot; alt=&quot;introducing a leak into your own javascript code&quot;&gt;&lt;/p&gt;
&lt;p&gt;这段代码刚看到的时候并没有发现有什么问题。我们可以认为&lt;code&gt;theTing&lt;/code&gt;在每次调用&lt;code&gt;replaceThing()&lt;/code&gt;的时候都会被覆写。 问题就是&lt;code&gt;someMethod&lt;/code&gt;拥有作为上下文的封闭作用域。这意味着&lt;code&gt;unused()&lt;/code&gt;是在&lt;code&gt;someMethod()&lt;/code&gt;内部的，甚至&lt;code&gt;unused()&lt;/code&gt;从未被调用过， 这也就以为了垃圾收集器无法释放&lt;code&gt;originalThing&lt;/code&gt;。有非常多的间接方法需要遵守。这在代码中并非是bug，但它会导致内存泄漏， 并且难以追踪。&lt;/p&gt;
&lt;p&gt;因此如果我们能够进入堆内存，并且观察它实际包含的内容，这会非常有助于我们最终错误源。幸运的是，我们可以这么做！ V8提供了一种方法用于转储（导出）当前的堆，并且v8-profiler将它用JavaScript接口的形式暴露了出来。&lt;/p&gt;
&lt;p&gt;如果内存使用持续攀升的话，这个简单的模块可以创建了堆的转储文件。当然，也有其他更巧妙的方法来探测类似的问题， 但对于我们的当前任务而言，这就足够了。如果存在内存泄漏，程序会中断，并且伴随着大量的类似文件。 因此你可以通过为这个模块关闭和增加一些提示工具的方式来模拟。在Chrome中也提供了类似的堆空间转储功能， 并且你可以直接通过Chrome开发者工具来分析v8-profiler的转储文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-v8-profiler-in-chrome.png&quot; alt=&quot;v8-profiler in chrome&quot;&gt;&lt;/p&gt;
&lt;p&gt;单一的堆转储可能并不能帮助你，因为它不能展示堆随着时间变化的增长过程。这就是为什么Chrome开发者工具允许你对比不同的内存概况文件。 你可以通过比较两个专注文件来获得差值，这样可以让你观察到内存占用的变化情况。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/understanding-nodejs-gc/img160105-heap-dump-comparison.png&quot; alt=&quot;heap dump comparison&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里能够看到一些问题所在，&lt;code&gt;longStr&lt;/code&gt;变量包含着一些星号组成的字符串，并且被&lt;code&gt;originalThing&lt;/code&gt;所引用，并且也被一些方法所引用， 然后也被……当然，你能看意识到这点。这里有一个非常长的引用路径，闭包上下文会导致&lt;code&gt;longStr&lt;/code&gt;长期占用内存，并且得不到释放。&lt;/p&gt;
&lt;p&gt;虽然这个问题导致了一个显而易见的问题，但是定位问题的过程总是相似的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不定时的创建堆的转储文件&lt;/li&gt;
&lt;li&gt;进行不同文件的对比，从而定位问题所在&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;正如我们所看到的，垃圾收集是个非常复杂的过程，并且即使代码没有问题也有可能会导致内存泄漏。 通过使用v8（和chrome开发者工具）提供的一些开箱即用的功能，能够帮助我们定位问题的源头， 如果你将这种机制构建到你的应用内，这将会非常有助于你发现和修复问题。&lt;/p&gt;
&lt;p&gt;当然，如果你问我上面的代码如何修复，其实非常的简单，只要在函数的最后加上一行&lt;code&gt;theThing = null;&lt;/code&gt;即可。&lt;/p&gt;
</description></item><item><title>互联网网站的反爬虫策略浅析</title><link>https://mikecyc.github.io/articles/anti-crawler-strategy/</link><pubDate>Sat, 14 May 2016 00:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/anti-crawler-strategy/</guid><author></author><description>&lt;p&gt;因为搜索引擎的流行，网络爬虫已经成了很普及网络技术，除了专门做搜索的Google，Yahoo，微软，百度以外，几乎每个大型门户网站都有自己的搜索引擎，大大小小叫得出来名字得就几十种，还有各种不知名的几千几万种，对于一个内容型驱动的网站来说，受到网络爬虫的光顾是不可避免的。&lt;/p&gt;
&lt;p&gt;一些智能的搜索引擎爬虫的爬取频率比较合理，对网站资源消耗比较少，但是很多糟糕的网络爬虫，对网页爬取能力很差，经常并发几十上百个请求循环重复抓取，这种爬虫对中小型网站往往是毁灭性打击，特别是一些缺乏爬虫编写经验的程序员写出来的爬虫破坏力极强，造成的网站访问压力会非常大，会导致网站访问速度缓慢，甚至无法访问。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;手工识别和拒绝爬虫的访问&lt;/h2&gt;
&lt;p&gt;相当多的爬虫对网站会造成非常高的负载，因此识别爬虫的来源IP是很容易的事情。最简单的办法就是用netstat检查80端口的连接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;netstat -nt | grep youhostip:&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt; | awk &lt;span class=&quot;string&quot;&gt;'{print $5}'&lt;/span&gt; | awk -F&lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'{print $1}'&lt;/span&gt;| sort | uniq -c | sort -r -n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这行shell可以按照80端口连接数量对来源IP进行排序，这样可以直观的判断出来网页爬虫。一般来说爬虫的并发连接非常高。&lt;/p&gt;
&lt;p&gt;如果使用lighttpd做Web Server，那么就更简单了。lighttpd的mod_status提供了非常直观的并发连接的信息，包括每个连接的来源IP，访问的URL，连接状态和连接时间等信息，只要检查那些处于handle-request状态的高并发IP就可以很快确定爬虫的来源IP了。&lt;/p&gt;
&lt;p&gt;拒绝爬虫请求既可以通过内核防火墙来拒绝，也可以在web server拒绝，比方说用iptables拒绝：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;iptables -A INPUT -i eth0 -j DROP -p tcp --dport &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;84.80&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;46.0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接封锁爬虫所在的C网段地址。这是因为一般爬虫都是运行在托管机房里面，可能在一个C段里面的多台服务器上面都有爬虫，而这个C段不可能是用户宽带上网，封锁C段可以很大程度上解决问题。&lt;/p&gt;
&lt;h2 id=&quot;-user-agent-&quot;&gt;通过识别爬虫的User-Agent信息来拒绝爬虫&lt;/h2&gt;
&lt;p&gt;有很多爬虫并不会以很高的并发连接爬取，一般不容易暴露自己；有些爬虫的来源IP分布很广，很难简单的通过封锁IP段地址来解决问题；另外还有很多各种各样的小爬虫，它们在尝试Google以外创新的搜索方式，每个爬虫每天爬取几万的网页，几十个爬虫加起来每天就能消耗掉上百万动态请求的资源，由于每个小爬虫单独的爬取量都很低，所以你很难把它从每天海量的访问IP地址当中把它准确的挖出来。&lt;/p&gt;
&lt;p&gt;这种情况下我们可以通过爬虫的User-Agent信息来识别。每个爬虫在爬取网页的时候，会声明自己的User-Agent信息，因此我们就可以通过记录和分析User-Agent信息来挖掘和封锁爬虫。我们需要记录每个请求的User-Agent信息，对于Rails来说我们可以简单的在app/controllers/application.rb里面添加一个全局的before_filter，来记录每个请求的User-Agent信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;logger.info &lt;span class=&quot;string&quot;&gt;&quot;HTTP_USER_AGENT #{request.env[&quot;&lt;/span&gt;HTTP_USER_AGENT&lt;span class=&quot;string&quot;&gt;&quot;]}&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后统计每天的production.log，抽取User-Agent信息，找出访问量最大的那些User-Agent。要注意的是我们只关注那些爬虫的User-Agent信息，而不是真正浏览器User-Agent，所以还要排除掉浏览器User-Agent，要做到这一点仅仅需要一行shell：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;grep HTTP_USER_AGENT production.log | grep -v -E &lt;span class=&quot;string&quot;&gt;'MSIE|Firefox|Chrome|Opera|Safari|Gecko'&lt;/span&gt; | sort | uniq -c | sort -r -n | head -n &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; &amp;gt; bot.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;统计结果类似这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;  &lt;span class=&quot;number&quot;&gt;57335&lt;/span&gt; HTTP_USER_AGENT Baiduspider+(+http://www.baidu.com/search/spider.htm)
  &lt;span class=&quot;number&quot;&gt;56639&lt;/span&gt; HTTP_USER_AGENT Mozilla/&lt;span class=&quot;number&quot;&gt;5.0&lt;/span&gt; (compatible; Googlebot/&lt;span class=&quot;number&quot;&gt;2.1&lt;/span&gt;; +http://www.google.com/bot.html)
  &lt;span class=&quot;number&quot;&gt;42610&lt;/span&gt; HTTP_USER_AGENT Mediapartners-Google
  &lt;span class=&quot;number&quot;&gt;19131&lt;/span&gt; HTTP_USER_AGENT msnbot/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;b (+http://search.msn.com/msnbot.htm)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从日志就可以直观的看出每个爬虫的请求次数。要根据User-Agent信息来封锁爬虫是件很容易的事情，lighttpd配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$HTTP&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;useragent&quot;&lt;/span&gt;] =~ &lt;span class=&quot;string&quot;&gt;&quot;qihoobot|^Java|Commons-HttpClient|Wget|^PHP|Ruby|Python&quot;&lt;/span&gt; {
  url.rewrite = ( &lt;span class=&quot;string&quot;&gt;&quot;^/(.*)&quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;/crawler.html&quot;&lt;/span&gt; )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用这种方式来封锁爬虫虽然简单但是非常有效，除了封锁特定的爬虫，还可以封锁常用的编程语言和HTTP类库的User-Agent信息，这样就可以避免很多无谓的程序员用来练手的爬虫程序对网站的骚扰。&lt;/p&gt;
&lt;p&gt;还有一种比较常见的情况，就是某个搜索引擎的爬虫对网站爬取频率过高，但是搜索引擎给网站带来了很多流量，我们并不希望简单的封锁爬虫，仅仅是希望降低爬虫的请求频率，减轻爬虫对网站造成的负载，那么我们可以这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$HTTP&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;user-agent&quot;&lt;/span&gt;] =~ &lt;span class=&quot;string&quot;&gt;&quot;Baiduspider+&quot;&lt;/span&gt; {
    connection.delay-seconds = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对百度的爬虫请求延迟10秒钟再进行处理，这样就可以有效降低爬虫对网站的负载了。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;通过网站流量统计系统和日志分析来识别爬虫&lt;/h2&gt;
&lt;p&gt;有些爬虫喜欢修改User-Agent信息来伪装自己，把自己伪装成一个真实浏览器的User-Agent信息，让你无法有效的识别。这种情况下我们可以通过网站流量系统记录的真实用户访问IP来进行识别。&lt;/p&gt;
&lt;p&gt;主流的网站流量统计系统不外乎两种实现策略：一种策略是在网页里面嵌入一段js，这段js会向特定的统计服务器发送请求的方式记录访问量；另一种策略是直接分析服务器日志，来统计网站访问量。在理想的情况下，嵌入js的方式统计的网站流量应该高于分析服务器日志，这是因为用户浏览器会有缓存，不一定每次真实用户访问都会触发服务器的处理。但实际情况是，分析服务器日志得到的网站访问量远远高于嵌入js方式，极端情况下，甚至要高出10倍以上。&lt;/p&gt;
&lt;p&gt;现在很多网站喜欢采用awstats来分析服务器日志，来计算网站的访问量，但是当他们一旦采用Google Analytics来统计网站流量的时候，却发现GA统计的流量远远低于awstats，为什么GA和awstats统计会有这么大差异呢？罪魁祸首就是把自己伪装成浏览器的网络爬虫。这种情况下awstats无法有效的识别了，所以awstats的统计数据会虚高。&lt;/p&gt;
&lt;p&gt;其实作为一个网站来说，如果希望了解自己的网站真实访问量，希望精确了解网站每个频道的访问量和访问用户，应该用页面里面嵌入js的方式来开发自己的网站流量统计系统。自己做一个网站流量统计系统是件很简单的事情，写段服务器程序响应客户段js的请求，分析和识别请求然后写日志的同时做后台的异步统计就搞定了。&lt;/p&gt;
&lt;p&gt;通过流量统计系统得到的用户IP基本是真实的用户访问，因为一般情况下爬虫是无法执行网页里面的js代码片段的。所以我们可以拿流量统计系统记录的IP和服务器程序日志记录的IP地址进行比较，如果服务器日志里面某个IP发起了大量的请求，在流量统计系统里面却根本找不到，或者即使找得到，可访问量却只有寥寥几个，那么无疑就是一个网络爬虫。&lt;/p&gt;
&lt;p&gt;分析服务器日志统计访问最多的IP地址段一行shell就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;grep Processing production.log | awk &lt;span class=&quot;string&quot;&gt;'{print $4}'&lt;/span&gt; | awk -F&lt;span class=&quot;string&quot;&gt;'.'&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.0&quot;}'&lt;/span&gt; | sort | uniq -c | sort -r -n | head -n &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; &amp;gt; &lt;span class=&quot;built_in&quot;&gt;stat&lt;/span&gt;_ip.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后把统计结果和流量统计系统记录的IP地址进行对比，排除真实用户访问IP，再排除我们希望放行的网页爬虫，比方Google，百度，微软msn爬虫等等。最后的分析结果就就得到了爬虫的IP地址了。以下代码段是个简单的实现示意：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;whitelist = []
IO.foreach(&lt;span class=&quot;string&quot;&gt;&quot;#{RAILS_ROOT}/lib/whitelist.txt&quot;&lt;/span&gt;) { |line| whitelist &amp;lt;&amp;lt; line.split[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].strip &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; line }

realiplist = []
IO.foreach(&lt;span class=&quot;string&quot;&gt;&quot;#{RAILS_ROOT}/log/visit_ip.log&quot;&lt;/span&gt;) { |line|  realiplist &amp;lt;&amp;lt; line.strip &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; line }

iplist = []
IO.foreach(&lt;span class=&quot;string&quot;&gt;&quot;#{RAILS_ROOT}/log/stat_ip.log&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |line|
  ip = line.split[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].strip
  iplist &amp;lt;&amp;lt; ip &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; line.split[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].to_i &amp;gt; &lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt; &amp;amp;&amp;amp; !whitelist.include?(ip) &amp;amp;&amp;amp; !realiplist.include?(ip)
end

Report.deliver_crawler(iplist)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析服务器日志里面请求次数超过3000次的IP地址段，排除白名单地址和真实访问IP地址，最后得到的就是爬虫IP了，然后可以发送邮件通知管理员进行相应的处理。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;网站的实时反爬虫防火墙实现策略&lt;/h2&gt;
&lt;p&gt;通过分析日志的方式来识别网页爬虫不是一个实时的反爬虫策略。如果一个爬虫非要针对你的网站进行处心积虑的爬取，那么他可能会采用分布式爬取策略，比方说寻找几百上千个国外的代理服务器疯狂的爬取你的网站，从而导致网站无法访问，那么你再分析日志是不可能及时解决问题的。所以必须采取实时反爬虫策略，要能够动态的实时识别和封锁爬虫的访问。&lt;/p&gt;
&lt;p&gt;要自己编写一个这样的实时反爬虫系统其实也很简单。比方说我们可以用memcached来做访问计数器，记录每个IP的访问频度，在单位时间之内，如果访问频率超过一个阀值，我们就认为这个IP很可能有问题，那么我们就可以返回一个验证码页面，要求用户填写验证码。如果是爬虫的话，当然不可能填写验证码，所以就被拒掉了，这样很简单就解决了爬虫问题。&lt;/p&gt;
&lt;p&gt;用memcache记录每个IP访问计数，单位时间内超过阀值就让用户填写验证码，用Rails编写的示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;ip_counter = &lt;span class=&quot;constant&quot;&gt;Rails&lt;/span&gt;.cache.increment(request.remote_ip)
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ip_counter
  &lt;span class=&quot;constant&quot;&gt;Rails&lt;/span&gt;.cache.write(request.remote_ip, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:expires_in&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;.minutes)
&lt;span class=&quot;keyword&quot;&gt;elsif&lt;/span&gt; ip_counter &amp;gt; &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;
  render &lt;span class=&quot;symbol&quot;&gt;:template&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'test'&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:status&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;401&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段程序只是最简单的示例，实际的代码实现我们还会添加很多判断，比方说我们可能要排除白名单IP地址段，要允许特定的User-Agent通过，要针对登录用户和非登录用户，针对有无referer地址采取不同的阀值和计数加速器等等。&lt;/p&gt;
&lt;p&gt;此外如果分布式爬虫爬取频率过高的话，过期就允许爬虫再次访问还是会对服务器造成很大的压力，因此我们可以添加一条策略：针对要求用户填写验证码的IP地址，如果该IP地址短时间内继续不停的请求，则判断为爬虫，加入黑名单，后续请求全部拒绝掉。为此，示例代码可以改进一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;before_filter &lt;span class=&quot;symbol&quot;&gt;:ip_firewall&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:except&lt;/span&gt; =&amp;gt; &lt;span class=&quot;symbol&quot;&gt;:test&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ip_firewall&lt;/span&gt;&lt;/span&gt;
  render &lt;span class=&quot;symbol&quot;&gt;:file&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;#{&lt;span class=&quot;constant&quot;&gt;RAILS_ROOT&lt;/span&gt;}&lt;/span&gt;/public/403.html&quot;&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:status&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;403&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;BlackList&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;?(ip_sec)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以定义一个全局的过滤器，对所有请求进行过滤，出现在黑名单的IP地址一律拒绝。对非黑名单的IP地址再进行计数和统计：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;ip_counter = &lt;span class=&quot;constant&quot;&gt;Rails&lt;/span&gt;.cache.increment(request.remote_ip)
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ip_counter
  &lt;span class=&quot;constant&quot;&gt;Rails&lt;/span&gt;.cache.write(request.remote_ip, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:expires_in&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;.minutes)
&lt;span class=&quot;keyword&quot;&gt;elsif&lt;/span&gt; ip_counter &amp;gt; &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;
  crawler_counter = &lt;span class=&quot;constant&quot;&gt;Rails&lt;/span&gt;.cache.increment(&lt;span class=&quot;string&quot;&gt;&quot;crawler/&lt;span class=&quot;subst&quot;&gt;#{request.remote_ip}&lt;/span&gt;&quot;&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !crawler_counter
    &lt;span class=&quot;constant&quot;&gt;Rails&lt;/span&gt;.cache.write(&lt;span class=&quot;string&quot;&gt;&quot;crawler/&lt;span class=&quot;subst&quot;&gt;#{request.remote_ip}&lt;/span&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:expires_in&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;.minutes)
  &lt;span class=&quot;keyword&quot;&gt;elsif&lt;/span&gt; crawler_counter &amp;gt; &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;
    &lt;span class=&quot;constant&quot;&gt;BlackList&lt;/span&gt;.add(ip_sec)
    render &lt;span class=&quot;symbol&quot;&gt;:file&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;subst&quot;&gt;#{&lt;span class=&quot;constant&quot;&gt;RAILS_ROOT&lt;/span&gt;}&lt;/span&gt;/public/403.html&quot;&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:status&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;403&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  render &lt;span class=&quot;symbol&quot;&gt;:template&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'test'&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:status&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;401&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果某个IP地址单位时间内访问频率超过阀值，再增加一个计数器，跟踪他会不会立刻填写验证码，如果他不填写验证码，在短时间内还是高频率访问，就把这个IP地址段加入黑名单，除非用户填写验证码激活，否则所有请求全部拒绝。这样我们就可以通过在程序里面维护黑名单的方式来动态的跟踪爬虫的情况，甚至我们可以自己写个后台来手工管理黑名单列表，了解网站爬虫的情况。&lt;/p&gt;
&lt;p&gt;关于这个通用反爬虫的功能，我们开发一个开源的插件：&lt;a href=&quot;https://github.com/csdn-dev/limiter&quot;&gt;https://github.com/csdn-dev/limiter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个策略已经比较智能了，但是还不够好！我们还可以继续改进：&lt;/p&gt;
&lt;p&gt;1、用网站流量统计系统来改进实时反爬虫系统&lt;/p&gt;
&lt;p&gt;还记得吗？网站流量统计系统记录的IP地址是真实用户访问IP，所以我们在网站流量统计系统里面也去操作memcached，但是这次不是增加计数值，而是减少计数值。在网站流量统计系统里面每接收到一个IP请求，就相应的cache.decrement(key)。所以对于真实用户的IP来说，它的计数值总是加1然后就减1，不可能很高。这样我们就可以大大降低判断爬虫的阀值，可以更加快速准确的识别和拒绝掉爬虫。&lt;/p&gt;
&lt;p&gt;2、用时间窗口来改进实时反爬虫系统&lt;/p&gt;
&lt;p&gt;爬虫爬取网页的频率都是比较固定的，不像人去访问网页，中间的间隔时间比较无规则，所以我们可以给每个IP地址建立一个时间窗口，记录IP地址最近12次访问时间，每记录一次就滑动一次窗口，比较最近访问时间和当前时间，如果间隔时间很长判断不是爬虫，清除时间窗口，如果间隔不长，就回溯计算指定时间段的访问频率，如果访问频率超过阀值，就转向验证码页面让用户填写验证码。&lt;/p&gt;
&lt;p&gt;最终这个实时反爬虫系统就相当完善了，它可以很快的识别并且自动封锁爬虫的访问，保护网站的正常访问。不过有些爬虫可能相当狡猾，它也许会通过大量的爬虫测试来试探出来你的访问阀值，以低于阀值的爬取速度抓取你的网页，因此我们还需要辅助第3种办法，用日志来做后期的分析和识别，就算爬虫爬的再慢，它累计一天的爬取量也会超过你的阀值被你日志分析程序识别出来。&lt;/p&gt;
&lt;p&gt;总之我们综合运用上面的四种反爬虫策略，可以很大程度上缓解爬虫对网站造成的负面影响，保证网站的正常访问。&lt;/p&gt;
</description></item><item><title>Hybrid App开发实战</title><link>https://mikecyc.github.io/articles/hybrid-app-development-combat/</link><pubDate>Thu, 12 May 2016 00:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/hybrid-app-development-combat/</guid><author></author><description>&lt;p&gt;近年来随着移动设备类型的变多，操作系统的变多，用户需求的增加，对于每个项目启动前，大家都会考虑到的成本，团队成员，技术成熟度，时间，项目需求等一堆的因素。因此，开发App的方案已经变得越来越多了。曾经有一段HTML5的小浪潮，无数的人参与或者看到过一个讨论：原生开发还是混合开发，又或者是Web开发？到底最佳实践是怎样的，笔者认为只有实践过的人才会知道。尤其是在这个充满各种变数的移动互联网时代。&lt;/p&gt;
&lt;h2 id=&quot;hybrid-app-&quot;&gt;Hybrid App现状分析&lt;/h2&gt;
&lt;h3 id=&quot;web-app&quot;&gt;Web App&lt;/h3&gt;
&lt;p&gt;毫无疑问Web App就是成本最低，最快速地解决方案了。尤其是近两年非常流行的响应式设计，Web App市场提供了非常好的实践场地。最近典型的Web App最佳案例是Sun天气应用了，其细节处理让人赞不绝口。&lt;/p&gt;
&lt;p&gt;一般来说，拥有下面特点的就是一个Web App了：使用浏览器运行；纯Web前端架构，很多重要手机特性无法访问，例如联系人以及Push notification之类的；Single Page App；销售渠道多限于浏览器。&lt;/p&gt;
&lt;h3 id=&quot;hybrid-app&quot;&gt;Hybrid App&lt;/h3&gt;
&lt;p&gt;所谓的Hybrid App其实会有不同的分支。而且会和Native应用有重合的地方。下面就说三种不同的解决方案。&lt;/p&gt;
&lt;p&gt;方案一：使用&lt;a href=&quot;http://phonegap.com/&quot;&gt;PhoneGap&lt;/a&gt;、&lt;a href=&quot;http://www.appcan.cn/&quot;&gt;AppCan&lt;/a&gt;之类的中间件，以WebView作为用户界面层，以Javascript作为基本逻辑，以及和中间件通讯，再由中间件访问底层API的方式，进行应用开发。这种架构一般会非常依赖WebView层的性能。&lt;/p&gt;
&lt;p&gt;方案二：使用Adobe Air、RubyMotion、Appcelerator或者是Xamarin这种非官方语言的工具，打包成原生应用的方式开发。为什么笔者会将它们定义为Hybrid App，主要是它们并没有很单纯地使用原生提供的语言进行开发，而是通过对开发者提供友好的开发工具，并折中地把这种开发语言转换成原生语言，最终打包出整个应用，所以也属于混合应用范畴。&lt;/p&gt;
&lt;p&gt;方案三：在开发原生应用的基础上，嵌入WebView但是整体的架构使用原生应用提供，一般这样的开发由Native开发人员和Web前端开发人员组成。Native开发人员会写好基本的架构以及API让Web开发人员开发界面以及大部分的渲染。保证到交互设计，以及开发都有一个比较折中的效果出来，优化得好也会有很棒的效果。（当年Facebook Three20就使用该方案）&lt;/p&gt;
&lt;p&gt;因此，Hybrid App有以下的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发时可能不采用或者大部分不采用原生语言，但是却有所有原生应用的特性；&lt;/li&gt;
&lt;li&gt;架构方案会和原生有出入，基本由工具而定；&lt;/li&gt;
&lt;li&gt;具有跨平台特性；&lt;/li&gt;
&lt;li&gt;一般开发相对原生开发的方式要简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;native-app&quot;&gt;Native App&lt;/h3&gt;
&lt;p&gt;Native App毫无疑问是最可靠的方案。但是学习成本，人才成本，开发效率以及照顾不同平台的特性去考虑，都成为了开发人员心目中的一道坎。至于说这道坎是不可逾越的还是一道让你提高的坎，笔者觉得完全取决于你自己。基于种种因素的考虑，估计很多人就会选择折中的方案到了Hybrid App的开发行列当中，包括笔者自己也是这样过来的。&lt;/p&gt;
&lt;p&gt;下面更多的内容都将围绕Hybrid App开发展开讨论。&lt;/p&gt;
&lt;h2 id=&quot;hybrid-app-&quot;&gt;Hybrid App在开发当中的优点和缺点&lt;/h2&gt;
&lt;p&gt;在Hybrid App的开发过程中，几种不同的方案笔者都有经历过。当然也经历到了Native App的开发阶段。在如此纠结复杂的过程中给了笔者不少的经验，下面笔者也会就自身的经验和大家分享这些方案当中的优缺点。对于初入行的朋友，笔者是从Web前端入行的，毕竟门槛较低，而且能够快速地培养自己的信心以及对代码的感觉。深入后就开始接触到移动开发这块了。所以会先从Hybrid App的第一种方案说起吧。&lt;/p&gt;
&lt;h3 id=&quot;-web-&quot;&gt;方案一（Web架构为重）&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全Web开发，一定程度上有利于Web前端技术人员快速地构建页面样式；&lt;/li&gt;
&lt;li&gt;有利于在不同的平台上面展示同一个交互层；&lt;/li&gt;
&lt;li&gt;便于调试，开发的时候可以通过浏览器的方式进行调试，工具丰富。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然说你可以专注在界面以及交互开发上了，但是这页会成为一个缺点，比如说要仿造一个iOS的默认设置界面，就需要大量的html以及css代码了，而且效果不一定和iPhone上面的界面一样好；&lt;/li&gt;
&lt;li&gt;正因为这是跨平台的开发，所以还是这句话：兼容是前端的痛。了解过在Android机器上面的Web开发就知道这个痛了。比如前些年在Android设备上面写圆角，border-radius:10px，在Android的设备上面会出现毛边。&lt;/li&gt;
&lt;li&gt;便于调试其实是在Web界面层的。但是实际上做Hybrid App开发的时候，你会遇到需求，进入手机的底层请求，做某些处理。比如说如果该应用有Push Notification服务的话，你就需要到底层，获取Push Notification发生时的数据，以及做相应的交互处理。当然类似PhoneGap这类框架，已经有很好的插件机制去帮助你解决类似的问题，当然还有Game Center之类的插件，具体的话可以到Github去关注PhoneGap官方的账户，资源非常丰富；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;-&quot;&gt;方案二（编译转换方式）&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用自己熟悉的语言，进行应用开发，比如RubyMotion，就是使用Ruby语言去做iOS开发，开发起来的话，代码量是数量级地下降啊。&lt;/li&gt;
&lt;li&gt;部分开发工具提供跨平台的功能，让你的应用能够快速地发布到不同的平台上面。比如Mono社区的Xamarin，就是典型的例子了。使用C#语言，能够把你的应用发布到iOS，Android以及WinPhone市场上面；&lt;/li&gt;
&lt;li&gt;开发出来的程序运行高效。大部分这种架构的应用，其实还是非常依赖底层的东西的，而且包括界面的东西，都是使用原生的API，效率就当然要比类似于PhoneGap这种架构要好了；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;严重依赖于其工具厂商提供的工具包，调试的时候就要有全套的工具。当然一般来说这些厂商都会以收费的形式发布他们的工具，相应的也有客服提供技术支持。遇到系统升级，第三方sdk升级，开发工具出现bug等，那么就要等待工具厂商解决了。相当于把风险压在对方身上了，自己却要承担责任。&lt;/p&gt;
&lt;h3 id=&quot;-native-&quot;&gt;方案三（Native架构为重）&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这无疑是最稳定的Hybrid App开发方式了，交互层的效率上由Native的东西解决了，而且架构上基本就是在App内写网页，连App Store都是采用了该种方案；&lt;/li&gt;
&lt;li&gt;开发时分工非常明确，底层的由iOS开发人员处理，上层的由Web前端开发人员处理；&lt;/li&gt;
&lt;li&gt;有效的在线参数配置方式，以便于及时在线替换界面；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;团队至少需要两个工程师，一个是Web的，一个是iOS的。当然如果开发人员会两种技术也可独立承担；&lt;/li&gt;
&lt;li&gt;还是运行效率，要权衡好多少界面采用Web来渲染，毕竟WebView的效率会相对降低，以前Facebook就是因为Web的渲染效率低下，把整个应用改为原生的解决方案。当然这里面可以通过优化来解决。但是优化也是有限度的，如Ruby创始人Matz所说优化要恰当（包括花的时间，技巧等），而且有时候的优化达到的回报率不一定达到你自己的期望。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hybrid-app-native-app-&quot;&gt;Hybrid App和Native App开发对比&lt;/h2&gt;
&lt;p&gt;因为方案三中的思想基本上就是原生应用的开发思想了。这里要做的对比应该不算大，因此笔者不会做太多的阐述介绍两者的不同。但是如果是偏重Web架构的，或者是以方案二这种透过特殊工具开发的，就和原生开发有对比了。这次笔者暂时会以方案一拿来讨论。讨论中主要会以架构，代码管理上来讨论，当然也会说到部分细节。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;架构讨论：&lt;/h2&gt;
&lt;p&gt;因为这是偏重于Web开发的应用，这里面就需要开发人员有很强烈的大型Web前端架构思想在里面。提到这里可能马上浮现在你脑海中的词语就是：angular.js，require.js，sea.js，backbone.js等。没错，这些工具都能够帮助你快速地梳理好思路，管理好你的Web应用。对开发者最友好的，发挥空间最大的非PhoneGap莫属了。所以笔者就会以PhoneGap应用展开讨论。（因为类似Sencha也有提供方案，但是Sencha本身是一个重量级的框架，而且有自己的思想在里头，加上他本身也提供开发工具，在这里就不适合讨论了。对于开发者来说可以根据自己的需求选择好工具）&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;从工具上看：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://angularjs.org/&quot;&gt;Angular.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用于双向绑定，网络请求，视图管理等工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://requirejs.org/&quot;&gt;Require.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;javascript模块化工具，在使用较多的交互对象，PhoneGap插件的时候，你就会发现一个强大的模块化工具会在开发的时候提供极好的帮助。能够帮助你把整体的代码，管理得井井有条。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jade-lang.com/&quot;&gt;Jade Template Engine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模板引擎。笔者个人比较推荐使用Jade，而且笔者本人也在博客中多次写到Jade在不同场景下使用的技巧的有关文章。主要是jade的语法太简洁了，而且面向JS开发人员非常友好。如果你还没有开始使用模板引擎，赶紧加入这个队列吧，你已经落后了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jquerymobile.com/&quot;&gt;Jquery Mobile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你暂时还没有一个设计师，但是又急于构造一个应用出来。jquery mobile就提供了多套不同风格的模板，供你使用，而且还含有不同的交互动画等。而且也是跨平台的。当然实际场景中，笔者觉得你会花很多时间在写css上面，因为设计总是天马行空的。当然你还有很多工具啦，例如sass，以及less.js等。&lt;/p&gt;
&lt;p&gt;PhoneGap.js或者Cordova.js&lt;/p&gt;
&lt;p&gt;做Phonegap开发必须使用的代码库，用于和PhoneGap框架通讯。现在这个库已经改名了，是Cordova。具体为什么改名，得问Adobe咯。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/purplecabbage/phonegap-plugins&quot;&gt;PhoneGap Plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PhoneGap的插件能够帮助你快速地抵达手机的其他API上面，直接使用Javascript来操控这些底层的API。例如调用Push Notification的相应发生的事件。&lt;/p&gt;
&lt;p&gt;从代码目录上面看混合应用中的Web层：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/js
      mainView.js
      settingView.js
      networkObject.js
      renderObject.js

/lib
      /PhoneGapPlugins
          push-notification-plugin.js
          pickerView.js
      PhoneGap.js
      zepto.js
      jquerymobile.js
      iscroll.js
      angular.js
      jade.js

/css
      /mainView
          listItemTemplate.css
          questionListTemplate.css
      /settingView
      /personView
      /layout
          navigationBar.css
          tabButton.css
      app.css

/template
      /mainView
          listItemTemplate.txt
          questionListTemplate.txt
      /settingView
      /personView
      /layout
          navigationBarTemplate.txt
          tabButtonTemplate.txt

index.html
app.js
require.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从代码的目录上面看，就是经典的静态网页文件的目录，非常简单。下面就用一句话来说说整个应用的运作过程吧：&lt;/p&gt;
&lt;p&gt;打开PhoneGap应用 -&amp;gt;进入 index.html -&amp;gt;运行require.js -&amp;gt;加载应用资源 -&amp;gt; app.js 控制整个应用 -&amp;gt; angular.js 进行事件绑定以及视图渲染 -&amp;gt;视图渲染的时候会将数据和加载好的视图模板（template目录下的代码）处理 -&amp;gt;经过jade模板引擎 -&amp;gt;渲染到相应的位置上&lt;/p&gt;
&lt;p&gt;就是如此简单。&lt;/p&gt;
&lt;p&gt;看完了简单的PhoneGap应用后，笔者们来看看简单iOS应用在开发时候的代码目录吧。思路上还是非常相似的。在这里面，笔者不会深入代码部分去讨论具体的实现以及细节上的东西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;demoApp
      /Resource
          navigationBar.png
          navigationBar@2x.png
    /demoApp
          AppDelegate.h
          AppDelegate.m
          /SettingViewController
                settingViewController.h
                settingViewController.m
          /MainViewController
                mainViewController.h
                mainViewController.m
          /Supporting Files
                demoApp-Info.plist
                InfoPlist.strings
                ...
      /plugin
          /AFNetworking
                AFHTTPClient.h
                AFHTTPClient.m
                AFHTTPRequestOperation.h
                AFHTTPRequestOperation.m
                ...
      /Frameworks
          CoreData.framework
          UIKit.framework
      /Products
          demoApp.app
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Objective-C 是一种通用、高级、面向对象的编程语言。Objective-C是承自Smalltalk的信息传递模型（message passing）。Objective-C里，与其说对象互相调用方法，不如说对象之间互相传递信息更为精确。Objective-C强调面对对象编程，且Objective-C中强制要求将类的（interface）与实现（implementation）分为两个部分。类的定义文件遵循C语言之惯例以 .h 为后缀，实现文件以 .m 为后缀。所以你会看到大量的类文件在里头，整个工程就是有不同的类构成的。（当然可能这么描述不太准确，但是便于大家理解）&lt;/p&gt;
&lt;p&gt;这就和丰富的Web前端有很大区别了，在Web前端开发里有HTML，CSS，JS三剑客，必须要用好这三个东西才可以把整个应用才可构建出来。但是在Native应用中，就很单一了。你只需要把握好Objective-C就可以了。因此对于原生应用来说，开发时只要遵守好规范，即使是一个新手参与开发，也可以快速地上手，看懂代码。因为模式已经定好，大家使用同一套的API。按着流程走就好了。当然学习Objective-C需要过程，但是对于拥有C语言，Java语言经验的开发者来说，是非常简单的事情。&lt;/p&gt;
&lt;p&gt;当然，原生开发的缺点也很明显了，就是满足不了你的跨平台需求。&lt;/p&gt;
&lt;p&gt;从代码目录上面看，其实也基本上看到笔者为什么使用多种JS库以及框架的原因了。主要的目的就是为了构建一个可维护的，具有规范性的Web应用。因为本身Javascript这门语言非常灵活，100个人可以具有100种风格，加上没有专门对于Javascript开设的课程，在过往都容易存在对这门语言的误解。基于种种的原因，就要约束好一个应用的代码风格，架构。此外，Javascript本身没有类的概念，所以在Javascript的面向对象编程中：Javascript的数据和成员封装很简单。没有类，完全是对象操作。这和Objective-C有很大不同。这个时候必须要有一种心态处理好整个Web应用：就是尽可能地抽象成对象，你的工作就是对象与对象之间存在交流。&lt;/p&gt;
&lt;p&gt;另外有一些点是值得开发者注意的。对于原生应用来说，不管是iOS的，还是Android的，都会提供一套原生界面的库。以Objective-C为例子。如果笔者需要调用Alert，笔者只需要编写：&lt;code&gt;UIAlertView * alertView = [[UIAlertViewalloc]init];&lt;/code&gt;，就把这个view声明好了。再去执行相应的方法，就可以了。但是对于Web应用来说，就需要编写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;'alertView'&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;确定&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;'#alertView'&lt;/span&gt;).show();&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;，一堆的css代码和html代码去实现。当然你会询问笔者，直接写 alert() 不就可以了吗？要是真这么简单的话，建议你在iOS的WebView中编写一下alert，实现：title 是提示，内容是：alert view，确定按钮的文字是：好的。你就知道WebView的限制在哪里了。&lt;/p&gt;
&lt;p&gt;因此要完成JS在Web App开发当中的最佳实践，肯定要学习优秀的思想和实现方法了。在这篇文章里面，笔者们暂时先不去做这种深入的讨论。而是先把例子抛给大家，也许会在下一次讨论的时候，再详细深入以下这两个项目。&lt;/p&gt;
&lt;p&gt;第一个是斯坦福的iOS开发公开课中的例子，使用objective-c实现，一个简单的卡牌游戏。这是经典的mvc开发了。项目地址如下：&lt;a href=&quot;https://github.com/lbj96347/Stanford-W2013-CardGame&quot;&gt;https://github.com/lbj96347/Stanford-W2013-CardGame&lt;/a&gt; ，如果您正在使用Mac，那恭喜你，可以马上编译这个游戏进行测试以及代码浏览。&lt;/p&gt;
&lt;p&gt;第二个是使用JavaScript编写的例子，实现同样的需求，做一个简单的卡牌游戏。但是使用的是HTML+CSS+JS开发。同样学习了继承以及mvc的思想。项目地址是：&lt;a href=&quot;https://github.com/lbj96347/JSMatchismo&quot;&gt;https://github.com/lbj96347/JSMatchismo&lt;/a&gt; ，再次恭喜你，不管使用什么电脑，都可以随时浏览代码以及运行该游戏。&lt;/p&gt;
&lt;h2 id=&quot;hybrid-app-&quot;&gt;Hybrid App的新思想&lt;/h2&gt;
&lt;p&gt;这两年多以来，因为市场的不同，也出现了不一样的需求，各个技术都有了新的发展。对于Hybrid App来说，其实都有了一些新的解决方案。为了解决问题其实最终思想都会被还原成以下几个点上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据需求，选择工具；&lt;/li&gt;
&lt;li&gt;用适当的工具做适当的事情，有针对性地解决问题；&lt;/li&gt;
&lt;li&gt;世界是平衡的，对于开发者来说，做的有用功越多，用户体验就越好，反之越差；&lt;/li&gt;
&lt;li&gt;跨平台是一个”幌子”，什么都做得到不代表什么都做得好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也是笔者体验最深的几个点。而且你会发现Hybrid技术也基本在跟随这几个点来走。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;根据需求，选择工具&lt;/h2&gt;
&lt;p&gt;如果你使用过Jquery Mobile，你做过过场动画（就是从一个view去到另一个view），过场动画在iOS的navigationController中很常见，而且很简单，效果很好很流畅。在Jquery Mobile中使用ajax，css去实现了，核心代码可能就几十行。可能跟iOS里面的差不多（如果包含动画），但是实际出来的效果却差强人意。会出现类似的问题：页面抖动，感觉不连贯，在部分的设备下运行缓慢。如果你的应用要求的体验并不是很高，例如一些新闻展示类应用，更强调排版。这里小小的体验差距，就可以忽略了。（因为英国BBC就是这么干的），但是如果你的应用非常强调体验细节，这里的解决方案可能就不适合了。或许你要做优化，但是优化的时间可能足以够你去学习更多的东西了。这样的话，你是继续选择用一个不成熟的工具，还是选择去学习一种新的语言呢？所以还是根据需求而定吧。&lt;/p&gt;
&lt;p&gt;另外一个例子。曾经有人跟笔者提及到，在使用HTML和CSS编写应用界面时确实很爽，但是效率不咋的。那为什么不尝试把应用内容直接搬到Canvas里面呢？构造一套足够强大的工具，一套足够彪悍的UI组件，把整个应用运行于Canvas中。这种想法是很好的，但是其实里面的短板页就出现了，Canvas的性能虽高，但是里面的元素组件多了你可以保证效果高？所有的东西都会依赖于JavaScript，这对于Javascript来说要构造足够强悍的面向对象的组件，也非简单之事，抛弃了CSS和HTML，意味着内部的设计组件能够高度定制，松耦合做得非常好。完全是实现了一套新的xcode和ui库啊。这就不是在解决一两个问题了。既然有这么一个工具，笔者为什么不选择更好的，例如Xamarin。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;用适当的工具做适当的事情&lt;/h2&gt;
&lt;p&gt;做游戏的朋友估计就深有体会了。为了解决Canvas性能的问题，越来越多的人和应用厂商（尤其是浏览器厂商），提供一种解决方案就是希望将Canvas API和系统底层的API打通。意味着你只需要编写Canvas代码，实际做渲染的时候使用的是系统底层的东西，整体上提高了性能。例如Ejecta &lt;a href=&quot;http://impactjs.com/ejecta&quot;&gt;http://impactjs.com/ejecta&lt;/a&gt; 这个东西。&lt;/p&gt;
&lt;p&gt;对于开发人员来说用Javascript编写游戏逻辑以及做各种控制都非常舒服，而且因为用的API相同，放到PC上（放开性能问题），同样可以运行。这就真的做到了跨平台，但是又不缺乏效率。让笔者感触最深的就是@大城小胖在做混合应用（做游戏）时的做法，小胖的游戏架构。JS负责逻辑，引擎。JS Binding绑定原生OpenGL，让原生的来做复杂的渲染处理。HTML CSS可以处理UI（比如一些Button）。这就是典型的：让工具去做其擅长的事情。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;跨平台是一个”幌子”&lt;/h2&gt;
&lt;p&gt;为什么这么说？笔者不是一直希望大家能够跨平台么？是的。但是要真的认清这个坎。从IE兼容，到目前多个浏览器的乱战，到iOS以及Android设备Web上的兼容，这不就是一个历史的例子嘛。跨平台不是不好，只是在一个时代里，你能够达到怎样的效果，真的是很难估量的。就好比你出国旅游，如果两国关系非常好，而且很多惯例法律一致，对你来说不会造成太多负担。但是如果语言不一样，生活习惯什么的都不同，你就很难适应。同样是人，你很难在不同的环境下生存。真正的跨平台，就意味着大家求同。这绝对不是一两天的事情，也非简单的事情。&lt;/p&gt;
&lt;p&gt;那为什么还要跨平台。业务需求嘛。在这里必须就要遵守根据需求选择工具，用适当的工具做适当的事情，根据实际情况来作开发。如果可以，笔者觉得很有必要都了解一遍，这样的话各种开发的思想就会影响到你，你就能够分辨到什么是好什么是坏，做更好的选择。例如笔者刚刚说到的过场动画的例子。其实完全可以使用笔者说的混合应用中，方案三，去解决这个问题。你无非就是希望用navigationController做一个漂亮的过场动画嘛，在iOS中几句代码就实现了。&lt;/p&gt;
&lt;p&gt;再说一个例子吧，如果你正在做一个todo-list的应用，其实无非就是简单存储数据以及做一些相关界面渲染。在使用原生的控件的话，有大堆的代码要写，而且还要处理好内存问题。但是其实如果使用Web的方式实现，比如&lt;a href=&quot;http://backbonejs.org/&quot;&gt;backbone.js&lt;/a&gt;。总体代码可能100行左右。就把整个应用实现了，包括本地存储。你要做的事情就是把整个界面搭建得漂亮些。可能就1个小时的工作。但是如果用原生开发，很难保证到一个小时内完成，因为调试编译都需要时间吧？况且还有界面呢。&lt;/p&gt;
&lt;p&gt;所以要认清跨平台这个”幌子”，并非所有的问题都用同一个方法处理。笔者们要融汇贯通嘛！&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;总结和笔者的感受&lt;/h2&gt;
&lt;p&gt;对于做Web App的坑，其实挺多的。这里无法一一表达。但是相信实践过就会知道如何更好地绕过这些坑（例如笔者说的过场动画的例子）。那么对于开发者来说要有坚强的毅力，努力去实践，满足自己永远不能满足的好奇心，因为最终的经验会给你带来不一样的感受，stay hungry。同时笔者们必须保持一颗学习的心，不断地吸收有营养的思想，学习新的知识，不要太容易满足，stay foolish。每一种语言都会有其中的思想，每一种工具都有自己解决问题的方法论。多尝试就能够给自己带来更优秀的架构，更优秀的应用，提供给用户更好的体验。当然，也会有更好的回报。&lt;/p&gt;
</description></item><item><title>使用youtube-dl下载YouTube视频</title><link>https://mikecyc.github.io/articles/use-youtube-dl-to-download-video/</link><pubDate>Thu, 12 May 2016 00:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/use-youtube-dl-to-download-video/</guid><author></author><description>&lt;p&gt;&lt;a href=&quot;http://youtube-dl.org/&quot;&gt;youtube-dl&lt;/a&gt;是一个使用python编写的脚本，可以下载热门视频网站的视频。在Linux系统下可以一健下载Youtube、Youku、Tudou等热门网站的视频。下面介绍使用方法。&lt;/p&gt;
&lt;h2 id=&quot;1-&quot;&gt;1、环境确认&lt;/h2&gt;
&lt;p&gt;youtube-dl需要Python 2.6以上的版本。因此需要先确认安装的Python版本。默认CentOS6.x是安装了2.6.6。通过以下命令可以查看版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;python –version
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2-&quot;&gt;2、下载安装&lt;/h2&gt;
&lt;p&gt;youtube-dl直接下载最新版到&lt;code&gt;/usr/local/bin/&lt;/code&gt;目录下并赋予权限即可使用。命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;wget http://youtube-dl.org/latest/youtube-dl -O /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin/youtube-dl
chmod a+x /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin/youtube-dl
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;3-&quot;&gt;3、用法&lt;/h2&gt;
&lt;p&gt;使用帮助命令查看其用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;youtube-dl -h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一些常用的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;youtube-dl --list-extractors  &lt;span class=&quot;comment&quot;&gt;#查看支持网站列表&lt;/span&gt;
youtube-dl -U  &lt;span class=&quot;comment&quot;&gt;#程序升级&lt;/span&gt;
youtube-dl --get-format URL &lt;span class=&quot;comment&quot;&gt;#获取视频格式&lt;/span&gt;
youtube-dl -F URL &lt;span class=&quot;comment&quot;&gt;#获取所有格式（目前仅支持YouTube），例如：&lt;/span&gt;
youtube-dl -F http://www.youtube.com/watch?v=n-BXNXvTvV4
[youtube] Setting language
[youtube] n-BXNXvTvV4: Downloading video webpage
[youtube] n-BXNXvTvV4: Downloading video info webpage
[youtube] n-BXNXvTvV4: Extracting video information
Available formats:
&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;      :      mp4    [&lt;span class=&quot;number&quot;&gt;1080&lt;/span&gt;x1920]
&lt;span class=&quot;number&quot;&gt;46&lt;/span&gt;      :      webm    [&lt;span class=&quot;number&quot;&gt;1080&lt;/span&gt;x1920]
&lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;      :      mp4    [&lt;span class=&quot;number&quot;&gt;720&lt;/span&gt;x1280]
&lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;      :      webm    [&lt;span class=&quot;number&quot;&gt;720&lt;/span&gt;x1280]
&lt;span class=&quot;number&quot;&gt;35&lt;/span&gt;      :      flv    [&lt;span class=&quot;number&quot;&gt;480&lt;/span&gt;x854]
&lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;      :      webm    [&lt;span class=&quot;number&quot;&gt;480&lt;/span&gt;x854]
&lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;      :      flv    [&lt;span class=&quot;number&quot;&gt;360&lt;/span&gt;x640]
&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;      :      mp4    [&lt;span class=&quot;number&quot;&gt;360&lt;/span&gt;x640]
&lt;span class=&quot;number&quot;&gt;43&lt;/span&gt;      :      webm    [&lt;span class=&quot;number&quot;&gt;360&lt;/span&gt;x640]
&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;      :      flv    [&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;x400]
&lt;span class=&quot;number&quot;&gt;36&lt;/span&gt;      :      &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;gp    [&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;x320]
&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;      :      &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;gp    [&lt;span class=&quot;number&quot;&gt;144&lt;/span&gt;x176]
&lt;span class=&quot;number&quot;&gt;137&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;1080&lt;/span&gt;p] (DASH Video)
&lt;span class=&quot;number&quot;&gt;136&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;720&lt;/span&gt;p] (DASH Video)
&lt;span class=&quot;number&quot;&gt;135&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;480&lt;/span&gt;p] (DASH Video)
&lt;span class=&quot;number&quot;&gt;134&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;360&lt;/span&gt;p] (DASH Video)
&lt;span class=&quot;number&quot;&gt;133&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;p] (DASH Video)
&lt;span class=&quot;number&quot;&gt;160&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;192&lt;/span&gt;p] (DASH Video)
&lt;span class=&quot;number&quot;&gt;141&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;k] (DASH Audio)
&lt;span class=&quot;number&quot;&gt;172&lt;/span&gt;    :      webm    [&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;k] (DASH Audio)
&lt;span class=&quot;number&quot;&gt;140&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;k] (DASH Audio)
&lt;span class=&quot;number&quot;&gt;171&lt;/span&gt;    :      webm    [&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;k] (DASH Audio)
&lt;span class=&quot;number&quot;&gt;139&lt;/span&gt;    :      mp4    [&lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;k] (DASH Audio)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;youtube-dl &lt;span class=&quot;operator&quot;&gt;-f&lt;/span&gt; format URL &lt;span class=&quot;comment&quot;&gt;#下载指定格式的视频，这里以下载1080p原画质量的视频格式为例:&lt;/span&gt;
youtube-dl &lt;span class=&quot;operator&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;137&lt;/span&gt; http://www.youtube.com/watch?v=n-BXNXvTvV4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充说明：&lt;/p&gt;
&lt;p&gt;我在VPS上试了试，下载YouTube的1080p速度飞快，几百兆的视频几乎瞬间搞定。下载回来重命名一下，放到Apache的htdoc目录里，再用百度或迅雷的离线下载拖回来，如此收藏YouTube视频易如反掌。&lt;/p&gt;
</description></item><item><title>如何进行海淘（海外购物）</title><link>https://mikecyc.github.io/articles/online-shopping-overseas/</link><pubDate>Wed, 11 May 2016 08:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/online-shopping-overseas/</guid><author></author><description>&lt;p&gt;海淘一词越来越流行，尤其是在白领阶层里，相信许多人也是想海淘一次，可是缺乏经验，不知道如何下手。相信有过海淘经验的朋友一定知道，许多国外的商城是不支持国内IP直接购买的。这时候就必须得用到VPN或者SSH，以达到更换IP的目的。如果你没有这样的工具，请到得自由 &lt;a href=&quot;http://devpn.info/&quot;&gt;devpn.info&lt;/a&gt; 获取，密码有效期一小时，可以连续获取。若直接使用国内IP购买，有可能出现以下几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;砍单，这是最常见的；&lt;/li&gt;
&lt;li&gt;无法访问该站点进行下单；&lt;/li&gt;
&lt;li&gt;账号被删 等结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来看看如何进行海淘:&lt;/p&gt;
&lt;h2 id=&quot;1-&quot;&gt;1、注册“转运”&lt;/h2&gt;
&lt;p&gt;大多数海外的B2C商家不支持直接发货到中国，即使支持，运费也不菲。转运公司可解决这一难题，它可以提供一个消费者专属海外收货地址，在海外代收商品后转发到国内，收取一定服务费用。美国在线零售市场繁荣，人民币对美元越来越划算，目前海外购以美国商家居多，大多数转运公司提供美国转运服务。比较有名的转运公司列表（风雷、百通、天翼、飞洋、久禾、瑞天、同舟、QQ-EX、友家、先锋等）。各家转运公司收费不一，清关速度略有差异，功能却大致相同。注册转运公司网站账号后，消费者可以在主页找到自己在美国的收货地址，各家操作大同小异。&lt;/p&gt;
&lt;h2 id=&quot;2-&quot;&gt;2、开始海淘&lt;/h2&gt;
&lt;p&gt;海淘之前，最好准备一张双币信用卡（Master、Visa、American Express、JCB等均可）。不少海外商家支持国内信用卡支付，例如最著名的Amazon（美国亚马逊），但也有部分商家不支持国内信用卡，这些商家我们就只能放弃了。购物方式与国内B2C差不多，只是在订单支付环节略有不同。基本流程为：注册-登录-添加商品至购物车-开始结算-填写收货地址（即转运公司提供的专属海外收货地址）-填写支付方式-确认订单-收到订单确认邮件。付款方式通常是信用卡支付，填写自己的卡号、姓名、有效期、cvv安全码即可。&lt;/p&gt;
&lt;p&gt;友情提示：部分网站会预授权1美元用来测试信用卡的有效性，不必担心，这1美元不会体现在账单中。&lt;/p&gt;
&lt;p&gt;Amazon是美国最大的B2C商城，产品种类繁多，价格通常较有优势，而且不对国内用户有任何限制，是海淘的首选网站。由于海淘需要一定的语言基础，而美国亚马逊同亚马逊中国网页样式、操作方法等方面基本一致，故建议网友们从Amazon入手开始自己的海淘之旅，同时也可在英语水平较好或有英语水平较好朋友的帮助下进行操作，或使用翻译工具临时解决问题。&lt;/p&gt;
&lt;h2 id=&quot;3-&quot;&gt;3、收发转运&lt;/h2&gt;
&lt;p&gt;支付订单几天后，转运公司网站可以查询海外收货地址/仓库是否收到货物，如果不放心或者迟迟未入库，可以查询网购商家的订单详情中的快递编号，然后到相应快递网站（例如UPS等）查询快递详情，必要时记录下运单号码与转运公司核实。&lt;/p&gt;
&lt;p&gt;友情提示：部分转运公司需要手工入库，这就需要网友在转运公司网站的个人中心中手动输入自己的运单号码。&lt;/p&gt;
&lt;p&gt;各家转运公司接下来的操作略有不同，但不外乎给转运公司的账户汇充足额转运费用、登记填写国内收货地址、确认转运公司入库单、核实称重（运费通常都以重量为依据）、提交转运申请、计算费用并扣款等。全部操作完成后，就可以等待商品到国内了。通常后台都会有一个跟踪运单页面，可以查看运单实时状态，了解送达时间。&lt;/p&gt;
&lt;p&gt;友情提示：有的转运公司需要预先充值才能使用其服务，可以适当多充一些，预防因费用不足延误收货时间。各转运公司都有详细的流程介绍，也有相关的论坛讨论相关问题，网友们不必过于担心流程繁琐，实际操作一次就可以明了。&lt;/p&gt;
&lt;h2 id=&quot;4-&quot;&gt;4、清关“入手”&lt;/h2&gt;
&lt;p&gt;海淘的产品必须清关才可进入国内配送环节。中华人民共和国海关总署《关于调整进出境个人邮递物品管理措施有关事宜》规定，自2010年9月1日起，取消过去对个人邮递物品的免税额，并且对邮递进境物品应缴进口税超过50元人民币的一律按商品价值全额征税。如果如被抽到需要缴纳关税履行义务，有可能导致到货时间延长。不过，消费者不需要懊恼，依法纳税是每个公民应尽的义务。海淘的产品通常算上关税也比国内购买的价格划算的多。如果产生关税，转运公司客服会电话或邮件通知你，充值后由转运公司代缴，货品被海关强制没收的可能性非常小。&lt;/p&gt;
&lt;p&gt;转运公司在国内通常使用EMS作为快递方式，也有部分使用中通、圆通等快递的。通常在转运网站的后台中可以查询到国内快递单号，用户可以根据单号在特快专递网站查询到包裹的实时状态。一旦国内快递运单号能查到状态，商品“入手”也就是2-3天的事情了。&lt;/p&gt;
&lt;h2 id=&quot;5-&quot;&gt;5、海淘总结&lt;/h2&gt;
&lt;p&gt;海淘虽然很有诱惑力，但仅适合部分产品不在大陆销售的产品（例如Kindle电子书阅读器等）以及与国内同型号产品价差较大的商品。然而一些过重的产品可能会因为转运费用抵消掉国内外的价差，海淘就不划算了。另外，应避免购买类似香水、喷雾类气压罐等海关禁运的产品。最后需要提醒的是，海淘需要一些耐心，海淘周期通常需要2周或20个工作日，这是非常正常的事情，如果有问题可以随时与转运公司或商家进行沟通。除此之外，若海淘产品有故障，返修不便也是不得不面对的问题。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;a. 部分网站有自己的Gift card（礼品券）系统，可以用来抵用现金。大家接触到较多的是Amazon的Gift card。由于网络市场上存在较多黑卡（盗刷信用卡所得），我们不建议用户去淘宝购买，而且，在人民币兑美元越来越划算的情况下，购买礼品券的繁琐和风险，相比于省的那点钱已经不再有优势。
b. 每个网站都有自己的免美国境内运费政策，例如Amazon满25美元可享受免运费、Timberland等品牌官网不时的有免运费活动。Amazon提供的Free Shipping（免运费）服务，通常需要5-7个工作日到达美国的收货地址。如果急需，新用户可以选择试用Amazon Prime（亚马逊优先服务），该服务每个用户可以免费试用一个月。通常而言，这项服务以包年形式出现，支付年费79美元，无论每次消费额为多少，均可享受免费2日送达服务。
友情提示：选择试用后，一定要记得去Amazon后台的“Prime服务自动续费”处关闭自动续费，否则1个月之后信用卡就自动划走年费。
c. 由于商品包装较重，商品较多的时候，可以通过合箱节省运费。例如一个1.1磅的电子书和0.3磅的耳机，如果原箱转运需要付2磅+1磅=3磅的运费，申请合箱后，转运公司的工作人员会拆开货物包装，把两件物品放在一起后重新打包称重，这样只需要2磅的运费。但合箱操作可能会带来收货的延迟，特别是在黑色星期五等转运公司不堪重负的时候，尽量不要提交合箱操作。部分转运还提供诸如加固、塞报纸等附加服务，这些服务可能需收取一定费用。 &lt;/p&gt;
</description></item><item><title>我为什么喜爱 CoffeeScript</title><link>https://mikecyc.github.io/articles/why-i-love-coffeescript/</link><pubDate>Tue, 10 May 2016 00:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/why-i-love-coffeescript/</guid><author></author><description>&lt;p&gt;我已经写了近10年的 JavaScript 代码了，对 JavaScript 的语法已经非常熟悉了，但当我某一天忽然见到 CoffeeScript 的时候，却一见钟情，为什么呢？&lt;/p&gt;
&lt;h2 id=&quot;javascript-&quot;&gt;JavaScript 陷阱&lt;/h2&gt;
&lt;p&gt;JavaScript 让人又爱又恨，因为它独特，卓越，而且不可或缺。JavaScript 现在如日中天， 未来发展更是不可小觑。 但毕竟它的设计非常仓促, 有些陷阱, 有些晦涩。当定义变量没有加 var 关系字在前面的时候，当前的变量就是全局的啦，这是一个很大的陷阱。&lt;/p&gt;
&lt;h2 id=&quot;javascript-&quot;&gt;JavaScript 没有美感&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript 是函数式语言;&lt;/li&gt;
&lt;li&gt;是基于 prototype 实现的面向对象语言;&lt;/li&gt;
&lt;li&gt;是动态语言, 更像 Lisp 而非 C/Java ; 但却使用了 C/Java 的语法;&lt;/li&gt;
&lt;li&gt;名字里面叫 Java, 其实和 Java 根本不搭边;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结论就是JavaScript的诞生是个悲剧. 它是函数式+动态语言的优秀内核, 却硬被绑上了C/Java的语法。也许是为了站在巨人的肩膀上进行推广的原因这样子设计，所以在语法上非常别扭。&lt;/p&gt;
&lt;h2 id=&quot;coffeescript-&quot;&gt;CoffeeScript 简洁&lt;/h2&gt;
&lt;p&gt;CoffeeScript 的最大功绩, 就是将 JavaScript 硬绑的 C/Java 语法抛弃了; 改为采用类似 Ruby/Python 的语法. Ruby/Python 本来就是深受 Lisp 影响的, 和 JavaScript 算是同门师兄, 他们的语法经过了实践考验, 是更适合函数式+动态语言内核的。&lt;/p&gt;
&lt;p&gt;CoffeeScript 只使用了 JavaScript 的”Good Parts(精粹)”, 抛弃了原来 JavaScript 晦涩的,容易出问题的那部分东西. 比如, 全局变量声明, with 啥的。&lt;/p&gt;
&lt;p&gt;CoffeeScript提供了很多语法糖, 让代码更优雅可读. 去主页仔细看看CoffeeScript的语法清单, 就会发现边边角角到处是创新. 这让编程语言真的成了开发者的朋友, 而不是机器的朋友.&lt;/p&gt;
&lt;p&gt;CoffeeScript 还提供了一个机会, 让你现在就可以使用 ECMAScript6 里面的特性. 将来有个更多新特性, CoffeeScript 也有机会在浏览器支持之前实现它们. 程序员面对的是 CoffeeScript 的优雅接口, 它是程序员和 JavaScript 之间的中间层, 脏活累活它都干了。&lt;/p&gt;
&lt;h2 id=&quot;-coffeescript&quot;&gt;如何快速适应 CoffeeScript&lt;/h2&gt;
&lt;p&gt;coffeescript 在设计思想上有很多和 JavasScript 不一样的地方，例如，几乎所有的语句都可以看做表达式、函数的返回值、this 的绑定、Destructuring Assignment 等等。如果还是以 JavaScript 的思维来写 coffeescript 的话，就不能发挥 coffeescript 的优势了。&lt;/p&gt;
&lt;p&gt;有一个工具 &lt;a href=&quot;http://js2.coffee/&quot;&gt;js2coffee&lt;/a&gt; 可以帮助你把 JavaScript 转换为 CoffeeScript 代码，你可以快速掌握JavaScript 与 CoffeeScript 的关系。&lt;/p&gt;
&lt;p&gt;阅读 CoffeeScript 相关的文档，我很喜欢下面的这个 pdf 文档：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;btn btn-primary&quot; href=&quot;coffeescript_slides.pdf&quot;&gt;CoffeeScript 小书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外就是多阅读优秀的开源代码，如静态网页生成器 &lt;a href=&quot;http://wintersmith.io/&quot;&gt;Wintersmith&lt;/a&gt;。我用 CoffeeScript 写的项目 &lt;a href=&quot;https://github.com/mikecyc/box.git&quot;&gt;Layout box&lt;/a&gt; 也可以参考。&lt;/p&gt;
</description></item><item><title>博客全新风格，新的起点</title><link>https://mikecyc.github.io/articles/hello-world/</link><pubDate>Sun, 01 May 2016 08:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/hello-world/</guid><author></author><description>&lt;p&gt;欢迎光临麦客园全新设计定制的博客，之前使用过octopress, Pelican, Nikola，虽然也很方便地写文章，但对于我个人的网站而言，我希望它不仅仅是一个博客系统，不光能产生固定格式的文章和分类，更希望它是一个完整的CMS,能根据个人的需要定制更多的内容展现方式。&lt;/p&gt;
&lt;!-- MORE --&gt;
&lt;p&gt;我希望我的博客有这些功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以用多种方式写文章，如 &lt;code&gt;Markdown&lt;/code&gt;, &lt;code&gt;TeX&lt;/code&gt;, &lt;code&gt;yaml&lt;/code&gt;等方式。&lt;/li&gt;
&lt;li&gt;相同的数据源可以生成不同风格展示页面，如演示或图表。&lt;/li&gt;
&lt;li&gt;快速生成静态页面，直接部署到github pages.&lt;/li&gt;
&lt;li&gt;支持插件机制，方便自己编写个人特殊的需求。&lt;/li&gt;
&lt;li&gt;能够保护私有内容，支持根据不同的配置文件输出不同的内容。&lt;/li&gt;
&lt;li&gt;需要能切割图片和加水印的功能。&lt;/li&gt;
&lt;li&gt;可以即时预览页面结果，方便调试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为我大部分时间都是写前端的代码，对 Javascript 比较熟悉，故看看 Node.JS 有没有什么开源的博客系统。通过 Google 查到了 Wintersmith, 一看描述就吸引了我：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Wintersmith 自称是基于 Node.js 的、灵活的、 简约的、 跨平台静态网站引擎。当然，“简约”是一个关键词 ！Wintersmith 并不适合于初学者，它比较适合中级或高级开发人员，这样运行起来才不费吹灰之力。Wintersmith 的解决方案并不是体积最小的。它用 CoffeeScript 作为开发语言，并内置了 Jade（模板标记语言） 和 Markdown 系统。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;真是太棒了，用 CoffeeScript 作为开发语言，我所喜爱的语法，像 Python 一样写 JavaScript，真是一大享受。通过扩展 Wintersmith，我已经实现了我所需要的全部功能。当然为了完成这个博客，我花了不少时间，同时通过阅读源代码让我更加体会到 Node.js 的精髓，也写了不少的插件来满足不同的需求。&lt;/p&gt;
&lt;p&gt;这次博客的改版，相对于之前的静态网页生成器，无论从内容的生成速度上，代码的可读性上，还是可扩展性都提升了几个档次。因时间比较仓促自己写的代码比较乱，希望有时间可以把定制打造的内容管理系统源代码整理并发布到 Github 上面，敬请期待。&lt;/p&gt;
</description></item><item><title>Python字符串格式化</title><link>https://mikecyc.github.io/articles/python-string-format/</link><pubDate>Wed, 06 Nov 2013 22:03:54 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/python-string-format/</guid><author></author><description>&lt;p&gt;在python中也有类似于c中的printf()的格式输出标记。在python中格式化输出字符串使用的是%运算符，通用的形式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;格式标记字符串 % 要输出的值组
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，左边部分的”格式标记字符串“可以完全和c中的一致。右边的’值组’如果有两个及以上的值则需要用小括号括起来，中间用短号隔开。重点来看左边的部分。左边部分的最简单形式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%cdoe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中的code有多种，不过由于在python中，所有东西都可以转换成string类型，因此，如果没有什么特殊需求完全可以全部使用’%s‘来标记。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;%s %s %s&amp;#39; % (1, 2.3, [&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;three&amp;#39;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它的输出为’1 2.3 [‘one’, ‘two’, ‘three’]’，就是按照%左边的标记输出的。虽然第一个和第二值不是string类型，一样没有问题。在这个过程中，当电脑发现第一个值不是%s时，会先调用整型数的函数，把第一个值也就是1转成string类型，然后再调用str()函数来输出。前面说过还有一个repr()函数，如果要用这个函数，可以用%r来标记。除了%s外，还有很多类似的code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;整型数：%d
无符号整型数：%u
八进制：%o
十六进制：%x   %X
浮点数：%f
科学记数法: %e   %E
根据数值的不同自动选择%e或%f: %g
根据数值的不同自动选择%E或%f: %G
&lt;/code&gt;&lt;/pre&gt;&lt;!-- TEASER_END --&gt;
&lt;p&gt;就跟前面说用\进行转义一样，这里用%作为格式标记的标识，也有一个%本身应该如何输出的问题。如果要在”格式标记字符串“中输出%本身，可以用%%来表示。
上面说的只是格式标记的最简间的形式，来看复杂一点的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;%6.2f&amp;#39; % 1.235
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这种形式中，在f的前面出现了一个类似小数的6.2它表示的意思是，总共输出的长度为6个字符，其中小数2位。还有更复杂的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;%06.2f&amp;#39; % 1.235
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在6的前面多了一个0,表示如果输出的位数不足6位就用0补足6位。这一行的输出为‘001.24’，可以看到小数也占用一位。类似于这里0这样的标记还有-、+。其中，-表示左对齐，+表示在正数前面也标上+号，默认是不加的。最后来看最复杂的形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;#39;%(name)s:%(score)06.1f&amp;#39; %{&amp;#39;score&amp;#39;:9.5, &amp;#39;name&amp;#39;:&amp;#39;newsim&amp;#39;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种形式只用在要输出的内容为dictionary（一种python的数据类型）时，小括号中的(name)和(score)对应于后面的键值对中的键。前面的例子可以看到，”格式标记字符串“中标记的顺序和”要输出的值组”中的值是一一对应的，有顺序，一对一，二对二。而在这种形式中，则不是，每个格式标记对应哪个值由小括号中的键来指定。这行代码的输出为：’newsim:0009.5’。&lt;/p&gt;
&lt;p&gt;有时候在%6.2f这种形式中，6和2也不能事先指定，会在程序运行过程中再产生，那怎么输入呢，当然不能用%%d.%df或%d.%d%f。可以用%&lt;em&gt;.&lt;/em&gt;f的形式，当然在后面的”要输出的值组“中包含那两个&lt;em&gt;的值。比如：’%&lt;/em&gt;.*f’ % (6, 2, 2.345)就相当于’%6.2f’ % 2.345。&lt;/p&gt;
&lt;p&gt;这是这本书到此为止看起来最复杂的内容。不过如果记不住，或不想那么耐烦，完全可以全部用%s代替，或者用多个”+”来构造类似的输出字符串。这里的%真有点除法的味道，怪不得设计者会选择用%这个除号。&lt;/p&gt;
&lt;p&gt;象C 中的sprintf函数一样，可以用“%”来格式化字符串。&lt;/p&gt;
&lt;h4 id=&quot;table-3-1-&quot;&gt;Table 3.1. 字符串格式化代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;格式    描述
%%        百分号标记
%c        字符及其ASCII码
%s        字符串
%d        有符号整数(十进制)
%u        无符号整数(十进制)
%o        无符号整数(八进制)
%x        无符号整数(十六进制)
%X        无符号整数(十六进制大写字符)
%e        浮点数字(科学计数法)
%E        浮点数字(科学计数法，用E代替e)
%f        浮点数字(用小数点符号)
%g        浮点数字(根据值的大小采用%e或%f)
%G        浮点数字(类似于%g)
%p        指针(用十六进制打印值的内存地址)
%n        存储输出字符的数量放进参数列表的下一个变量中
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>移植《关于浏览器和网络的 20 项须知》代码</title><link>https://mikecyc.github.io/articles/20thingsilearned/</link><pubDate>Sat, 12 Oct 2013 18:03:54 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/20thingsilearned/</guid><author></author><description>&lt;p&gt;《关于浏览器和网络的20项须知》（20 Things I Learned About Browsers and the Web）是Google Chrome团队于2010年底推出的网络图书，上周新增了15种语言版本，包括简体中文、繁体中文、英文、法文、德文、荷兰文、意大利文、西班牙文、巴西葡萄牙文、捷克文、波兰文、俄文、日文、印度尼西亚文以及菲律宾文，让更多读者能快速认识浏览器和网络的基本常识。
&lt;!-- TEASER_END --&gt;&lt;/p&gt;
&lt;p&gt;《浏览器和网络世界20大须知》内容浅显易懂，并邀请知名插画家Christoph Niemann绘制插图，大大增加了阅读趣味。&lt;/p&gt;
&lt;p&gt;前端开发程序师非常值得花时间深入阅读的代码，可以学到很多的html5的知识。&lt;/p&gt;
&lt;h2 id=&quot;-20-html5-&quot;&gt;《关于浏览器和网络的20项须知》所使用HTML5技术：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用HTML5 canvas element打造动态的换页特效。&lt;/li&gt;
&lt;li&gt;利用Application Cache API，让用户首次进入后具备离线阅读功能。&lt;/li&gt;
&lt;li&gt;以Local Storage API作为书签功能，用户回来后，可以进入上次离开时的页面。&lt;/li&gt;
&lt;li&gt;History API，当你在翻页时，只有书的区块出现变化，而不是重载整个页面，所以感觉很流畅。但是网址列里的URL会跟着变化，所以你可以单独将某一页加入书签，而搜索引擎也能收录单一页面。&lt;/li&gt;
&lt;li&gt;使用多种CSS3的特性，如网页字体、动画和阴影等，提高视觉吸引力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了更方便学习，我把《关于浏览器和网络的20项须知》的代码提取出来，删除了语言选择功能和导航功能，仅供参考。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;预览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/articles/20thingsilearned/google-20things.jpg&quot; alt=&quot;Google 20things&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/laboratory/20things/&quot; target=&quot;_blank&quot; class=&quot;btn btn-primary btn-wide&quot;&gt;点击预览&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;源代码&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;btn btn-primary btn-wide&quot; href=&quot;/laboratory/20things/20things.zip&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
</description></item><item><title>Nginx如何设置Django的https重定向</title><link>https://mikecyc.github.io/articles/how-to-set-https-in-django-and-nginx/</link><pubDate>Thu, 22  Aug 2013 21:44:21 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/how-to-set-https-in-django-and-nginx/</guid><author></author><description>&lt;h2 id=&quot;-&quot;&gt;遇到的问题&lt;/h2&gt;
&lt;p&gt;出于网络安全考虑增加SSL协议的连接，但发现Django在重定向跳转的时候总是回到普通的HTTP协议，而不是HTTPS协议。查了资料看到&lt;code&gt;HttpRequest.is_secure()&lt;/code&gt;方法用来判断是否https连接，如果是的话就返回&lt;code&gt;True&lt;/code&gt;。在Django 1.4 之前只能在Python的环境上去设置，而1.4重新改写了is_secure()方法，可以自己指定判断的变量和值。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;h2 id=&quot;-nginx-django&quot;&gt;如何设置Nginx和Django&lt;/h2&gt;
&lt;p&gt;Google了好几篇文章，都说在Nginx配置文件中增加下面的设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;proxy_&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;_header X-Forwarded-Protocol &lt;span class=&quot;variable&quot;&gt;$scheme&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但因为我用的Nginx没有通过代理的方式，所以没有办法拿到值，需要修改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;uwsgi_param HTTP_X_FORWARDED_PROTOCOL &lt;span class=&quot;variable&quot;&gt;$scheme&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加在&lt;code&gt;location /{}&lt;/code&gt;里面。然后再在Django工程的&lt;code&gt;settings.py&lt;/code&gt;里增加 &lt;code&gt;SECURE_PROXY_SSL_HEADER&lt;/code&gt;变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;SECURE_PROXY_SSL_HEADER = (&lt;span class=&quot;string&quot;&gt;'HTTP_X_FORWARDED_PROTOCOL'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'https'&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法就是Nginx会设置SSL连接&lt;code&gt;HTTP_X_FORWARDED_PROTOCOL&lt;/code&gt;的值为&lt;code&gt;https&lt;/code&gt;，当然也要告诉Django判断的名称和值，详细参考Django文档 &lt;a href=&quot;https://docs.djangoproject.com/en/1.4/ref/settings/#secure-proxy-ssl-header&quot;&gt;SECURE_PROXY_SSL_HEADER&lt;/a&gt; 。&lt;/p&gt;
</description></item><item><title>两个非常有用的Bash脚本编程命令</title><link>https://mikecyc.github.io/articles/strong-bash/</link><pubDate>Tue, 13  Aug 2013 15:55:02 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/strong-bash/</guid><author></author><description>&lt;p&gt;Shell脚本可以完成很多任务，但因为Shell脚本运行时遇到异常还是会继续运行，这些问题有时很难发现，所以有两个命令可以帮助你来调试脚本，这是非常有用的命令。&lt;/p&gt;
&lt;h2 id=&quot;-set-u&quot;&gt;命令一：使用 Set -u&lt;/h2&gt;
&lt;p&gt;你有没有因为一个变量没有初始化而经常崩溃？我知道我有，而且很多次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;chroot=&lt;span class=&quot;variable&quot;&gt;$1&lt;/span&gt;
...
rm -rf &lt;span class=&quot;variable&quot;&gt;$chroot&lt;/span&gt;/usr/share/doc
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;如果你忘记初始化一个变量就运行上面的脚本，你将会删除所有的系统文件，而不是只在chroot目录下的文档。你要做些什么呢？幸运的是bash为您提供了&lt;code&gt;set -u&lt;/code&gt;，当你尝试使用一个未初始化的变量将会自动退出脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;mike% bash /tmp/shrink-chroot.sh
&lt;span class=&quot;variable&quot;&gt;$chroot&lt;/span&gt;=
mike% bash -u /tmp/shrink-chroot.sh
/tmp/shrink-chroot.sh: line &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;variable&quot;&gt;$1&lt;/span&gt;: unbound variable
mike%
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;-set-e&quot;&gt;命令二：使用 Set -e&lt;/h2&gt;
&lt;p&gt;你写的每一个脚本都应该在开始包含&lt;code&gt;set -e&lt;/code&gt;。这告诉bash如果任何一语句返回一个非真的值将退出脚本。使用&lt;code&gt;-e&lt;/code&gt;的好处是它可以防止滚雪球般的变成严重错误，能尽快地捕获到错误。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-e&lt;/code&gt;来检查错误为把你释放出来。如果你忘了检查，bash将为你做。不幸的是这意味着你不能检查&lt;code&gt;$?&lt;/code&gt;返回值，因为你得不到值如果返回不是为零的话。你可以使用另外一种结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [ &lt;span class=&quot;string&quot;&gt;&quot;$?&quot;&lt;/span&gt;&lt;span class=&quot;operator&quot;&gt;-ne&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;command failed&quot;&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以替换成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt; || { &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;command failed&quot;&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ! &lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;command failed&quot;&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你有一个命令需要返回非零值，或者你对返回值不感兴趣？你可以使用&lt;code&gt;command || true&lt;/code&gt;，或者你有一段很长的代码，你可以暂时关闭错误检查，但我建议你谨慎使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; +e
&lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;1
&lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt;2
&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;-e&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相关文档说明，默认情况下bash返回管道中最后一个命令的值，也许不是你想要的结果。例如，&lt;code&gt;false | true&lt;/code&gt;会被视为成功执行。如果你想让命令执行失败，可以使用&lt;code&gt;set -o pipefail&lt;/code&gt;。&lt;/p&gt;
</description></item><item><title>notepad++安装markdown插件</title><link>https://mikecyc.github.io/articles/setup-md-notepad/</link><pubDate>Thu, 08  Aug 2013 11:22:05 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/setup-md-notepad/</guid><author></author><description>&lt;p&gt;Notepad++ 是一款非常友好的编辑器，轻巧、便捷、高效、插件丰富… 同时 Notepad++ 支持用户自定义语法高亮&lt;/p&gt;
&lt;p&gt;GitHub上已经有人编写好开源的 Markdown 规则： &lt;a href=&quot;https://github.com/thomsmits/markdown_npp&quot;&gt;https://github.com/thomsmits/markdown_npp&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-notepad-markdown-&quot;&gt;一、让Notepad++ 高亮支持 Markdown 语法:&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;开始菜单 -&amp;gt; 运行(或者直接按 Ctrl+R) -&amp;gt; 输入 %APPDATA%\Notepad++
将 userDefineLang.xml 放置到此目录
重启 Notepad++
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在语言菜单下可以看到自定义的 Markdown 高亮规则。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;&lt;img src=&quot;/articles/setup-md-notepad/md-notepad.jpg&quot; alt=&quot;Markdown 高亮选项&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;-markdown-&quot;&gt;二、附上我个人的Markdown高亮代码文件（针对黑色背景）&lt;/h2&gt;
&lt;p&gt;因Github里的高亮支持文件表现不是非常理想，所以我加以修改并分享出来。&lt;/p&gt;
&lt;p&gt;点击下载&lt;a href=&quot;/articles/setup-md-notepad/userDefineLang.xml&quot;&gt;我的Markdown高亮代码文件&lt;/a&gt;&lt;/p&gt;
</description></item><item><title>Nikola-静态博客A.K.A引擎，我是怎样创建Shisaa.jp</title><link>https://mikecyc.github.io/articles/nikola-web/</link><pubDate>Thu, 01  Aug 2013 18:52:05 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/nikola-web/</guid><author></author><description>&lt;h2 id=&quot;-&quot;&gt;写在前面的话&lt;/h2&gt;
&lt;p&gt;当我在Google搜索用git做博客的时候我看到github提供了免费静态页面服务，而且提供Jekyll工具，允许用户用轻量级标记语言（比如Markdown）来写文章，然后生成博客页面。同类的工具还有Octopress。但用的是Ruby语言，在windows下安装环境特别麻烦。因我比较喜欢用Python，再继续搜索，看到了Pelican，只支持Python2.7以上版本，把本地的Python版本更新到2.7版本，好不容易安装好了Pelican环境，但发现Pelican用Makefile来管理项目，而Makefile在Windows下就是一个恶梦。最后看到了Nikola，按照官方文档很快就上手了，而且默认的样式还是特好看的，所以就最终选择了Nikola来建立静态博客。&lt;/p&gt;
&lt;p&gt;在Nikola的有一篇文章&lt;a href=&quot;http://shisaa.jp/postset/nikola-web.html&quot; title=&quot;Goes from installing to developing a custom theme.&quot;&gt;Tutorial by Tim van der Linden&lt;/a&gt;，正好解决了我对Nikola的一些问题，为了日后查阅方便，也为了能让更多母语是中文的网络爱好者认识Nikola，故翻译了这篇文章。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;hr&gt;
&lt;h2 id=&quot;-&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;首先，非常感谢Nikola创作者Roberto Alsina，给这篇文章&lt;a href=&quot;http://getnikola.com/blog/new-nikola-tutorial.html&quot; title=&quot;基于Nikola建立博客shisaa.jp&quot;&gt;很高的评价&lt;/a&gt;，并将其嵌入到Nikola文档中！&lt;/p&gt;
&lt;p&gt;当我设计Shisaa.jp的时候我花一些时间思考用怎么样的“后端”。什么样的系统建站…使用CMS吗？
我使用Drupal有丰富的经验，这可能是我的首选……但熟悉Drupal的，也知道一些难以忽视的事实：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Drupal是用PHP编写的，这不是我所向往的编程语言。&lt;/li&gt;
&lt;li&gt;Drupal有很强大的工具，但运行会慢得像蜗牛，这是一个典型的多用途CMS的负担，几乎这样的框架系统都是这样。&lt;/li&gt;
&lt;li&gt;Drupal 8即将推出，这是一个全新和充满亮点的版本，是建立另一框架之上（symfony），所以它是框架之上的框架…在正常的情况下，意味着它将变得更慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，不用Drupal，那用什么呢？Wordpress, Joomla…？这…永远…不可能，它们都是用PHP做后端的语言。&lt;/p&gt;
&lt;p&gt;好，不用PHP驱动系统…我更喜欢用Python，所以可能是Plone, Pylons, Pyramid, …？&lt;/p&gt;
&lt;p&gt;可能……&lt;/p&gt;
&lt;p&gt;但仍有一个挥之不去的声音在我的后脑环绕……“我真的需要一个CMS”？&lt;/p&gt;
&lt;p&gt;我的意思是，你想想，我只这个网站的唯一作者，不需要其它的用户登录来更新内容，也不需要花哨的界面。
还有安全问题……每一个动态系统在互联网上很容易受各种可怕的攻击……因为他们是动态的。
哦，还有性能问题，访问一些普通的HTML文件绝对比动态拼凑一个页面请求（即使缓存）要快很多倍。&lt;/p&gt;
&lt;p&gt;所以我决定建立这个网站用&lt;strong&gt;静态&lt;/strong&gt;方式，为什么呢？&lt;/p&gt;
&lt;p&gt;当你决定建立自己的静态网站，基本上你有两种选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手工方式写每个HTML文档&lt;/li&gt;
&lt;li&gt;使用一种静态页面生成器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果选择方案一，你必须要花大量的工作在自己的网站上。如果你的网站或博客只包含几页而且只每年更新两次，那这古老的手工制作的网页是可行的。但是，如果你需要频繁地更新网站，从头写每一页并且保持所有的菜单和深层链接将成为地狱的工作……这会使你失去所有建立个人网站的乐趣。&lt;/p&gt;
&lt;p&gt;这就需要静态页面生成器来帮助你。一旦安装了它，它就会为你做繁重的工作，因此您可以集中精力写你的博客，维护公司的网站，在线更新图片最新事件等..&lt;/p&gt;
&lt;p&gt;你会问：“但我将需要大量的技术知识，如果我使用这些类型的系统的话”。不，你不会的。
这些系统只需要很少的一些配置就可以了（但系统本身可不是，为什么？），良好的工具可以让你有条不紊地进行工作！&lt;/p&gt;
&lt;h2 id=&quot;-nikola&quot;&gt;关于Nikola&lt;/h2&gt;
&lt;p&gt;事实上我对Nikola Tesla有极大的兴趣，我很快就感觉到&lt;a href=&quot;http://getnikola.com/&quot; title=&quot;Nikola主页&quot;&gt;这点&lt;/a&gt;，Nikola将是我的首选武器，它是相当快速和优雅的系统，具有不错的功能集合，而且可扩展。它还包含了一个实用的工具包来帮助你建立或创作你的网站。它甚至是多语言的！&lt;/p&gt;
&lt;p&gt;去阅读&lt;a href=&quot;http://getnikola.com/handbook.html&quot; title=&quot;Nikola手册&quot;&gt;Roberto Alsina的Nikola手册&lt;/a&gt;关于这个项目背后的动机和美丽的功能并提供的工具。在该网站上，你还会发现有相当详细的指南教你如何开始建立自己的网站。尽管Roberto尽最大努力来指导你使用Nikola，但我觉得还有有点抽象，尤其在主题化上，只好自己去探索。&lt;/p&gt;
&lt;p&gt;所以我现在带你进行短暂的旅行，告诉你我是如何用Nikola设置，部署和制作这个网站，基于上述原因，主要是基本设置和建立您的自定义主题。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;环境设置&lt;/h2&gt;
&lt;p&gt;在进入主题之前，我们必须先配置Nikola……当然配置Nikola，我们必须配置我们的Python环境。
由于许多程序在您的Unix系统上安装了各种版本的Python，有时很难设置一个干净的可以运行你项目的工作空间。
你需要一个基于特定Python版本的沙箱开发环境。对于这个沙箱环境，我使用流行的&lt;a href=&quot;http://www.virtualenv.org/&quot; title=&quot;Virtualenv工程首页&quot;&gt;Virtualenv&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用Virtualenv你能做到以上所有要求…在你选择的目录下部署一个新的虚拟环境，并把Shell指向那个目录，你就可以开始建网站了。首先来安装Virtualenv：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们可以设置我们的虚拟环境&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ virtualenv --python=python2.&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; yourdir
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：我告诉Virtualenv使用Python2.7版本，Nikola 5.3 &lt;em&gt;是&lt;/em&gt; 兼容Python 3的，但如果你想提供一个很好的谷歌地图XML，你只有采用Python2.x版本。
完成了Virtualenv沙箱的设置，&lt;strong&gt;进到该目录&lt;/strong&gt;加载该沙箱环境到当前的Shell：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;source&lt;/span&gt; bin/activat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;瞧，你会发现在当前目录名插入到你使用的Shell前面，这意味着一切都很好。现在…来安装Nikola！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ pip install nikola
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将会安装的是Nikola5.3（在当时写这的时候），并为您安装所有必要的依赖。现在，我们开始初始化我们的网站。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;初步建立&lt;/h2&gt;
&lt;p&gt;要建立一个新的站点，你只要简单地运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ nikola init shisaa.jp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自从Nikola 5.2 将创建一个 &lt;em&gt;空&lt;/em&gt; 的网站，只包含基本的目录结构和配置文件的示例。
你可以编译这个网站，它将工作在这个沙箱外面。 5.2之前的init命令将生成一个空的网站并填充示范数据。
如果您还想这种行为只需要附加”–demo”标示在init命令后面。&lt;/p&gt;
&lt;p&gt;进入你建立的目录，你会发现创建的网站目录结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;files
galleries
listings
posts
stories
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们快速看一下每个目录的作用（和Nikola的一些特性）：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;files&lt;/em&gt; 目录包含静态资源，无论你使用什么主题它都是有效的。
&lt;em&gt;Galleries&lt;/em&gt; Nikola展示照片画廊功能。在这个目录里，只要你喜欢，你可以创建尽可能多的目录，每一个目录都是单独的画廊。
接下来是 &lt;em&gt;listings&lt;/em&gt; ，这个目录将包含源代码列表。你可以把你的原始源代码文件放在这里，Nikola将为这个目录的每个代码文件创建一个目录页和语法高亮的HTML文件。
&lt;em&gt;Posts&lt;/em&gt; 是Nikola最重要的目录。该目录将存放您选定的标记语言的文章文件。
最后一个目录是 &lt;em&gt;stories&lt;/em&gt; ，它包含了所有的将要显示的“静态”页面（不是贴子页面）。像 &lt;em&gt;关于&lt;/em&gt; 或者 &lt;em&gt;联系我们&lt;/em&gt; 页面放在这里将感觉非常好。&lt;/p&gt;
&lt;p&gt;但在明白Nikola如何处理这些目录之前，我们先看一下配置文件…它控制你的整个Nikola站点。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;创建基本配置&lt;/h2&gt;
&lt;p&gt;就像我们上面看到的，基本的站点初始化给你一个内容充实的 &lt;em&gt;conf.py&lt;/em&gt; 文件。
为了学习……我建议你备份conf.py文件和建立一个空的文件。&lt;/p&gt;
&lt;p&gt;打开你最喜欢的编辑器，让我们开始建立一个新的Nikola站点配置文件。
由于Nikola是一个Python的应用程序，也是用Python语言编写的配置文件。
因此，我们必须做的第一件事是加载一些Python模块，所以Nikola可以成功地解析该文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; __future__ &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; unicode_literals
&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os
&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们就可以设置我们的网站的一些基本信息和变量，将应用到我们的模板中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;BLOG_AUTHOR = &lt;span class=&quot;string&quot;&gt;&quot;Tim van der Linden&quot;&lt;/span&gt;
BLOG_TITLE = &lt;span class=&quot;string&quot;&gt;&quot;Shisaa.jp&quot;&lt;/span&gt;
BLOG_URL = &lt;span class=&quot;string&quot;&gt;&quot;http://Shisaa.jp&quot;&lt;/span&gt;
BLOG_EMAIL = &lt;span class=&quot;string&quot;&gt;&quot;tim@Shisaa.jp&quot;&lt;/span&gt;
BLOG_DESCRIPTION = &lt;span class=&quot;string&quot;&gt;&quot;A blog about Programming, Japan and Photography&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;够简单了吧？现在来保存这个文件。它的名字 &lt;em&gt;必须&lt;/em&gt; 是conf.py和 &lt;em&gt;必须&lt;/em&gt; 保存在你的Nikola站点的根目录下。&lt;/p&gt;
&lt;p&gt;接下来要做的事情是告诉Nikola我们想处理的不同内容。因为Nikola是一个博客引擎的心脏，我们会从那里开始。&lt;/p&gt;
&lt;p&gt;静态网站生成器遵循大致相同的原则：你用标记语言写你的文章或网页，定义这些标记文件的模板，并把一些静态文件，如CSS或JavaScript，然后你让生成器做所有逻辑和输出目录以HTML格式呈现出来。所以我们首先定义一个地方放我们的博客标记文章文件。在Nikola，默认是 &lt;em&gt;post&lt;/em&gt; 目录。实际上，你可以把它放在任何你喜欢的地方，只要你告诉Nikola哪里可以找到它。&lt;/p&gt;
&lt;p&gt;所以接下来，我们要进入我们的配置文件建立一个哈希表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;post_pages = (
    (&lt;span class=&quot;string&quot;&gt;&quot;posts/*.md&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;posts&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;post.tmpl&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;),
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个哈希表称为 &lt;em&gt;post_pages&lt;/em&gt; ，并遵循一定的语法。首先，在我们定义目录下，我们会把我们的文章（基于 &lt;em&gt;md&lt;/em&gt; 语法的文件）放在那里。然后我们定义内容的类型，Nikola会在那里找到它，（您还可以定义页面在这里，稍后将会看到），第三项是渲染时使用的模板文件。最后一项是一个布尔值，你可以设置告诉Nikola是否在网站RSS中包括这些文件。&lt;/p&gt;
&lt;p&gt;接下来Nikola需要知道用哪种语言写的静态文件。你可以简单地写 &lt;em&gt;HTML&lt;/em&gt; 或使用其它Nikola支持的标记语言，如 &lt;em&gt;Markdown&lt;/em&gt; 或 &lt;em&gt;reStructuredText&lt;/em&gt; 。为此，我们定义另一个称为&lt;em&gt;post_compilers&lt;/em&gt;哈希表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;post_compilers = {
    &lt;span class=&quot;string&quot;&gt;&quot;markdown&quot;&lt;/span&gt;: (&lt;span class=&quot;string&quot;&gt;'.md'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'.mdown'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'.markdown'&lt;/span&gt;),
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的情况只用Markdown。所以这是我唯一的定义。您可以使用更多的语言，在这基础上扩展Nikola并定义使用正确的编译器转换成HTML。&lt;/p&gt;
&lt;p&gt;相当的好玩，是不是？&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;写你的文章&lt;/h2&gt;
&lt;p&gt;Nikola有一个命令来启动一个新的文章：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ nikola new_post &lt;span class=&quot;operator&quot;&gt;-f&lt;/span&gt; markdown
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会问你一些必要的元数据并加到文本本身。注意 &lt;em&gt;-f&lt;/em&gt; 标志，如果你使用多种标记语言，你将要指定你想要的语言来编写的新的文章。&lt;/p&gt;
&lt;p&gt;用不同的方式，对我来说更方便，手动创建你的文章文件，并将其保存在你的文章目录下。&lt;/p&gt;
&lt;p&gt;要手动开始一篇文章，只需打开你喜欢的编辑器和文章目录下保存该文件用得体的名字。
对于这个文件我们必须做的第一件事就是宣告一些元数据，Nikola将使用这些数据生成HTML页面，内部链接和标签。
每行只包含一个元数据，使用的语法是，以两个点和空格开始。默认的文章或页面将像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.. title: Your blog post title
.. slug: any-unique-slug-you-like
.. date: 2013/02/27 18:52:05
.. tags: web, blog
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置之后你可以开始写你心爱的文章，用你标记的语言格式，就是定义在 &lt;em&gt;conf.py&lt;/em&gt; 的标语语言。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;第一次编译&lt;/h2&gt;
&lt;p&gt;好，虽然对于这个过程有点早，但我们已经可以做一个测试版本看到目前为止的效果，明确我们已经做了什么。&lt;/p&gt;
&lt;p&gt;只要运行下面的命令并观察输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ nikola build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nikola将创建一个名为”output”的目录，整个网站的结构将放在那里。
关于构建过程中的一个不错的细节，就是它仅仅编译修改过的文件和依赖文件。
也就是说你更新的博客文章，只有博客的文章将被重新渲染，包括文件中链接指向到该文章….仅此而已。
这意味着，你最初的构建可能需要几秒钟，但在那之后就更快了！&lt;/p&gt;
&lt;p&gt;如果一切顺利的话，你现在可以查验实际的编译结果。
怎么样做到呢，你可以设置一个Web服务器并指向 “output” 目录…或者你可以使用Nikola来构建服务器。
在同一个站点的根目录下，启动Nikola来建立服务器：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ nikola serve
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看吧…你在浏览器上输出“ &lt;a href=&quot;http://localhost:8000&quot;&gt;http://localhost:8000&lt;/a&gt; ”（端口配置在你网站的config.py文件中），看到是多么美丽的画面！
我通常会打开一个新的终端，并运行Nikola​​服务器，只有这样，我在主终端可以随时用 “nikola build” 编译文章。
请记住，对于每一个新的终端，开始之前要再次设置你的虚拟环境源。&lt;/p&gt;
&lt;p&gt;“但是网站看起来像Nikola的首页！”，你会说。这是对的。
你看到的是Nikola自带的默认主题。
我们希望网站完全是我们自己的，所以这也意味着要自定义生成主题。&lt;/p&gt;
&lt;p&gt;所以，你猜怎么着…接下来： &lt;em&gt;创建你的主题&lt;/em&gt; ！&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;创建主题样式&lt;/h2&gt;
&lt;p&gt;正如我们上面看到的，你可以告诉Nikola使用已经定义在 &lt;em&gt;post_pages&lt;/em&gt; 哈希表中的任何一个模板文件（模板文本用 &lt;em&gt;tmpl&lt;/em&gt; 后缀名）。
但这些模板文件，位于何处？嗯……在一个主题中。&lt;/p&gt;
&lt;p&gt;Nikola始终搜索 &lt;em&gt;themes&lt;/em&gt; 目录中的主题并加载你定义在 &lt;em&gt;conf.py&lt;/em&gt; 中的主题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;THEME = &lt;span class=&quot;string&quot;&gt;'shisaa'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在Nikola将在 &lt;em&gt;themes&lt;/em&gt; 目录下搜索名为 &lt;em&gt;shisaa&lt;/em&gt; 的目录。&lt;/p&gt;
&lt;p&gt;“等一下！”，你迅速发问，“我之前没有配置一个主题，但仍然有默认的…是什么魔力发生这一切？”&lt;/p&gt;
&lt;p&gt;嗯，很高兴你发问。&lt;/p&gt;
&lt;p&gt;当你安装Nikola之后，Nikola已经附带了几个主题。&lt;/p&gt;
&lt;p&gt;这些的主题存放在Nikola的源码中。得到它们，你只需打开 &lt;em&gt;lib&lt;/em&gt; 目录在你的Python安装目录下。
请记住，如果你通过Virtualenv安装的Python，那么你需要打开这个环境的 &lt;em&gt;lib&lt;/em&gt; 目录。&lt;/p&gt;
&lt;p&gt;在你的 &lt;em&gt;lib&lt;/em&gt; 中你将会看到你的Python版本，打开之后你会发现有个目录叫 &lt;em&gt;site-packages&lt;/em&gt;。
在那里你会看到Nikola目录，在那里有名叫 &lt;em&gt;data&lt;/em&gt; 目录。
在 &lt;em&gt;data&lt;/em&gt; 目录下有一个名叫 &lt;em&gt;themes&lt;/em&gt; 的目录，里面包含了所有的基本主题。
如果你没有定义任何主题在你的conf.py中，它会使用名为 &lt;em&gt;default&lt;/em&gt; 主题。&lt;/p&gt;
&lt;p&gt;呵呵，谜底揭晓！&lt;/p&gt;
&lt;p&gt;也许你会发现：在主题中有一个叫 &lt;em&gt;Orphan&lt;/em&gt; 的主题。这实际上是一个剥离下来的主题，你可以使用它。
所以如果你厌倦去阅读代码，只需复制到你的主题目录，重新命名，并开始调整主题。
或者只是继续阅读代码…跟我一样会找到更多的乐趣！&lt;/p&gt;
&lt;p&gt;你还在吗？好！让我们继续主题化！&lt;/p&gt;
&lt;p&gt;Nikola支持 &lt;em&gt;Mako&lt;/em&gt; 或者 &lt;em&gt;Jinja&lt;/em&gt; 主题引擎，我选择 &lt;em&gt;Mako&lt;/em&gt; 生成shisaa主题。
Mako只需要几个目录在你的主题目录里面，在那里你可以存储不同类型的文件。你基本上需要三个目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assets&lt;/li&gt;
&lt;li&gt;templates&lt;/li&gt;
&lt;li&gt;messages&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;assets&lt;/em&gt; 目录将包含所有的静态文件，如CSS, Javascript, images，…都是针对你的主题的。
&lt;em&gt;Templates&lt;/em&gt; 将存放真正的 &lt;em&gt;.tmpl&lt;/em&gt; 文件。
最后 &lt;em&gt;messages&lt;/em&gt; 目录包含Nokia支持的多语言文件。现在，我们将只专注于英语。&lt;/p&gt;
&lt;p&gt;让我们先从最精彩的 &lt;em&gt;templates&lt;/em&gt; 目录开始。&lt;/p&gt;
&lt;p&gt;Nikola使用一组硬编码文件名的模板文件，他将会被找到。
在Nikola的&lt;a href=&quot;http://getnikola.com/theming.html&quot; title=&quot;基本主题化的文档&quot;&gt;基本主题文件&lt;/a&gt;是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base.tmpl&lt;/li&gt;
&lt;li&gt;index.tmpl&lt;/li&gt;
&lt;li&gt;post.tmpl&lt;/li&gt;
&lt;li&gt;listing.tmpl&lt;/li&gt;
&lt;li&gt;list.tmpl&lt;/li&gt;
&lt;li&gt;list_post.tmpl&lt;/li&gt;
&lt;li&gt;tags.tmpl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有少数其它几个（即 &lt;em&gt;gallery.tmpl&lt;/em&gt;, &lt;em&gt;story.tmpl&lt;/em&gt; ），但这个更进一步的特性。&lt;/p&gt;
&lt;p&gt;但在开始编译这些文件之前，让我们对Mako有一个大概的了解：&lt;/p&gt;
&lt;p&gt;Mako是用Python编写的模板引擎来&lt;em&gt;运行&lt;/em&gt;Python。它与Python语言有非常密切的关系。一个Mako模板文件可以很容易从其它Mako模板文件继承，使您能保持模板的逻辑整洁。你可以继承一个文件，使用下面的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来你将使用继承的模板块代码，你使用你的主模板：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;footer&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;footer&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;This is a footer, just static html!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在在你继承的模板文件中你可以调用该功能块，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;${footer()}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了继承，你可以使用任何Python代码嵌入到你的模板文件中。
要使用Python代码，以 &lt;em&gt;&amp;lt;%&lt;/em&gt; 开始和 &lt;em&gt;%&amp;gt;&lt;/em&gt; 结束你的代码块来完成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%!&lt;/span&gt;
    &lt;span class=&quot;attribute&quot;&gt;text&lt;/span&gt; = &quot;&lt;span class=&quot;attribute&quot;&gt;foobar&lt;/span&gt;&quot;
%&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，你也可以使用控制结构构建循环或进行简单的判断，甚至捕获异常，…
我建议你​​去阅读&lt;a href=&quot;http://docs.makotemplates.org/en/latest/&quot; title=&quot;Mako的文档&quot;&gt;Mako的文档&lt;/a&gt;，你将会发现这是个非常强大的模板语言。
现在，让我们动手创建一个主题采用Mako的语法！&lt;/p&gt;
&lt;p&gt;如果你还没有这样做，在你的Nikola项目的根目录下创建你的主题目录，然后在 &lt;em&gt;conf.py&lt;/em&gt; 中宣告你的主题。&lt;/p&gt;
&lt;p&gt;主题需求的第一件事是翻译的语言信息，即使你的网站将是只用一种语言，你仍然需要设置正确的翻译字符串。
该消息翻译存储你的主题中称为 “messages” 的目录下。所以打开你的主题并创建该目录。&lt;/p&gt;
&lt;p&gt;你想支持的每种翻译语言采用的语法如下：&lt;strong&gt;语言代码*&lt;/strong&gt;_messages.py&lt;em&gt;。
例如默认的英文翻译，创建一个文件名为 &lt;/em&gt;en_messages.py&lt;em&gt;。
此文件 &lt;/em&gt;必须&lt;em&gt; 有导入模块和叫 &lt;/em&gt;MESSAGES* 的字典包含如下固定数量的项：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; __future__ &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; unicode_literals

MESSAGES = {
    &lt;span class=&quot;string&quot;&gt;&quot;LANGUAGE&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;English&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Posts for year %s&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Posts for year %s&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Archive&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Archive&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Posts about %s&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Posts about %s&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Tags&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Tags&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Also available in&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Also available in&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;More posts about&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;More posts about&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Posted&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Posted&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Original site&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Original site&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Read in English&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Read in English&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Newer posts&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Newer posts&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Older posts&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Older posts&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Previous post&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Previous post&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Next post&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Next post&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;old posts page %d&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;old posts page %d&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Read more&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Read more&quot;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&quot;Source&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Source&quot;&lt;/span&gt;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使你不使用这些翻译，你仍然需要保留着。&lt;/p&gt;
&lt;p&gt;接下来我们来构建我们的实际呈现出最终的HTML模板文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：每个TMPL文件的改变更适合我的Shisaa.jp的需要。我不作评论或多种语言功能。如果你想看到原来的主题代码，请仔细阅读 Orphan 主题的 tmpl 文件！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我们需要相当多的HTML片段和很多Mako的结构在我们的模板文件中，可以想象是非常不可读的。
为了防止这种情况，有是一个很好的做法，利用Mako的&lt;em&gt;定义块&lt;/em&gt;。
正如我们先前看到的，Mako让您能够定义的“代码块”，你以后可以很简单地调用函数块。&lt;/p&gt;
&lt;p&gt;你问我：“我要怎么才能做到呢？”。&lt;/p&gt;
&lt;p&gt;好吧，让我们按所说的进行练习，在你的&lt;em&gt;templates&lt;/em&gt;目录下创建两个文件。
一个称为 &lt;em&gt;base.tmpl&lt;/em&gt; ，另一个称为 &lt;em&gt;base_helper.tmpl&lt;/em&gt;。
&lt;em&gt;base.tmpl&lt;/em&gt; 是主模板文件，也就是HTML标记的框架。这里定义了 &lt;em&gt;head&lt;/em&gt;, &lt;em&gt;html&lt;/em&gt; 和 &lt;em&gt;body&lt;/em&gt; 标记。
&lt;em&gt;base_helper.tmpl&lt;/em&gt; ，Nikola不关心这个文件，但你可以用它来保存可重用的定义块，这样你可以保持&lt;em&gt;base.tmpl&lt;/em&gt;的简洁。
其实，你可以调用户任何称为”helper”的文件（或只要你高兴，可以创造尽可能多的helper文件），但清晰地命名 &lt;em&gt;base_helper.tmpl&lt;/em&gt; 是这样一个不错的选择。&lt;/p&gt;
&lt;p&gt;现在，让我们使用这些文件，怎么样？&lt;/p&gt;
&lt;p&gt;首先，要在文件 &lt;em&gt;base.tmpl&lt;/em&gt; 能够使用自定义的块中声明，你首先要告诉 &lt;em&gt;base.tmpl&lt;/em&gt; 文件。
你可以简单地导入定义块使用Mako的“命名空间”属性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%namespace&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base_helper.tmpl import=&quot;&lt;/span&gt;&lt;span class=&quot;value&quot;&gt;*&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一行简单地告诉Mako从 &lt;em&gt;base_helper.tmpl&lt;/em&gt; 文件导入所有的定义块。
如果你只想要导入helper文件中的部分块，只需删除通配符(*)，将名字组成用逗号分隔的字符串放在 &lt;em&gt;import=””&lt;/em&gt; 属性中。
将这一行放在 &lt;em&gt;base.tmpl&lt;/em&gt; 文件的顶部。&lt;/p&gt;
&lt;p&gt;在开始之前，让我们在 &lt;em&gt;base.tmpl&lt;/em&gt; 中创建框架代码。
shisaa框架看起来有点像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;doctype&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${lang}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是这虽然美丽，但只能显示为空白页。我们需要显示实际内容。&lt;/p&gt;
&lt;p&gt;首先，&lt;em&gt;head&lt;/em&gt;，你不觉得它看起来很空吗？没有标题，没有css，没有favicon，…
我们可以直接把它放在 &lt;em&gt;base.tmpl&lt;/em&gt; 文件中，但我们希望它尽可能整洁。
所以最好是在 &lt;em&gt;base_helpers.tmpl&lt;/em&gt; 文件中定义，让我们来定义header块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_head()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;title&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${title} | ${blog_title}&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;description&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${description}&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;author&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${blog_author}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;${title} | ${blog_title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;image/x-icon&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/img/favicon.ico&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;image/x-icon&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/img/favicon.ico&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;shortcut icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/css/reset.css&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;text/css&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/css/theme.css&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;text/css&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- Le HTML5 shim, for IE6-8 support of HTML5 elements --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--[if lt IE 9]&amp;gt;
    &amp;lt;script src=&quot;/assets/js/html5shiv.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;/assets/js/html5shiv-print.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;&lt;/span&gt;
    %if rss_link:
        ${rss_link}
    %endif
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这看起来有点像你所期望的 &lt;em&gt;head&lt;/em&gt; 标记，对不对？&lt;/p&gt;
&lt;p&gt;正如你看到，我们可以在主题里使用存储在&lt;em&gt;conf.py&lt;/em&gt;的变量。
要使用一个变量，你只需用 &lt;em&gt;${}&lt;/em&gt; 语法。也就是你看到 &lt;em&gt;${lang}&lt;/em&gt; 变量设置在当前的HTML文件&lt;em&gt;base.tmpl&lt;/em&gt;中。
注意有一些变量不在配置文件里定义（如 &lt;em&gt;title&lt;/em&gt; ），而是从你的文章或网页的标记文件的元数据里面得到。&lt;/p&gt;
&lt;p&gt;所以现在我们有一个整洁的header，但如何放在&lt;em&gt;base.tmpl&lt;/em&gt;的正确位置？
简单地通过使用与呈现变量的相同语法，唯一的区别是，应该被称为定义块——他们的功能，而不是简单的变量。
这意味着需要调用，用 &lt;em&gt;${foo()}&lt;/em&gt; 而不是 &lt;em&gt;${foo}&lt;/em&gt;。
所以调用这个定义块在&lt;em&gt;头&lt;/em&gt;部：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;doctype&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${lang}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
        ${html_head()}
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，关于 &lt;em&gt;body&lt;/em&gt; 部分？这里需要显示我们的文章或页面等的实际内容..
我们总是希望在屏幕上显示一个固定的标题，所以让我们添加一个很好语义的 &lt;em&gt;h1&lt;/em&gt; 来包含标题，并使其可随时点击回到主页：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;blog-title&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${abs_link('/')}&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;title&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${blog_title}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${blog_title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步，我们需要一个占位符，这样Nikola就知道在哪里呈现所有的内容在我们架构中。
在这里我们可以引进Mako的 &lt;em&gt;继承&lt;/em&gt; 概念。&lt;/p&gt;
&lt;p&gt;我们所要做的唯一事情是定义一个 &lt;em&gt;block&lt;/em&gt; 让所有其他的模板文件来填充。
你的页面标题下面，加入下面的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有其他模板将参考此标记，并在那里将内容呈现出来。
这些模板将需要继承自&lt;em&gt;base.tmpl&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他们将包含相同名称的块，具体的模板标记如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    ...
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不很简单？&lt;/p&gt;
&lt;p&gt;如果你还不完全明白，不用担心，我们还会回来，首先让我们完成我们的&lt;em&gt;base.tmpl&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;我还需要呈现页脚的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;${content_footer}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但 &lt;em&gt;content_footer&lt;/em&gt; 这个变量从哪里来的呢？在conf.py中定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;CONTENT_FOOTER = &lt;span class=&quot;string&quot;&gt;'Contents &amp;amp;copy; {date} &amp;lt;a href=&quot;mailto:{email}&quot;&amp;gt;{author}&amp;lt;/a&amp;gt; - Powered by &amp;lt;a href=&quot;http://getnikola.com&quot;&amp;gt;Nikola&amp;lt;/a&amp;gt;'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在你的配置文件中找到这行，并调整成为你的要求！&lt;/p&gt;
&lt;p&gt;现在唯一缺少的是一个菜单。&lt;/p&gt;
&lt;p&gt;你会注意到shisaa有一个侧边风格的菜单。
这个菜单生成的链接是在conf.py中的&lt;em&gt;SIDEBAR_LINKS&lt;/em&gt;字典中定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;SIDEBAR_LINKS = {
    DEFAULT_LANG: (
        (&amp;#39;/&amp;#39;, &amp;#39;Home&amp;#39;),
        (&amp;#39;/archive.html&amp;#39;, &amp;#39;Blog),
        (&amp;#39;/stories/about.html&amp;#39;, &amp;#39;About),
    ),
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你会发现菜单中也多语种，但因为我只使用一种语言，只宣告 &lt;em&gt;DEFAULT_LANG&lt;/em&gt; 字典就足够。
在字典中，你首先宣告链接路径，然后是你想显示的菜单名称。
这个标记定义在 &lt;em&gt;base_helper.tmpl&lt;/em&gt; 文件中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_sidebar_links()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    %for url, text in sidebar_links[lang]:
        % if rel_link(permalink, url) == &quot;#&quot;:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;active&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${text}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %else:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${text}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endif
    %endfor
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“这是怎么得来的呢？”，你可能会感到奇怪。&lt;/p&gt;
&lt;p&gt;正如我们已经看到我们的小Mako的介绍，你有可以在模板里使用内部控制结构和循环。
上面我们看到这两者的定义块。&lt;/p&gt;
&lt;p&gt;首先，我们在 &lt;em&gt;SIDEBAR_LINKS&lt;/em&gt; 字典的当前（或默认）语言循环。
在字典的每一项页面链接如果是指向当前页，那么就加上 “&lt;em&gt;active&lt;/em&gt;“ 样式。
这样我们的工具栏菜单就被渲染了。&lt;/p&gt;
&lt;p&gt;当我们把所有这些内容放在一起，shisaa的&lt;em&gt;base.tmpl&lt;/em&gt;看起来像这样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%namespace&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base_helper.tmpl&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;import&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;*&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;doctype&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${lang}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
        ${html_head()}
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;blog-title&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${abs_link('/')}&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;title&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${blog_title}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${blog_title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;sidebar&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
                ${html_sidebar_links()}
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;footer&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${content_footer}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;base_helper.tmpl&lt;/em&gt; 看起来像这样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_head()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;title&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${title} | ${blog_title}&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;description&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${description}&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;author&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${blog_author}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;${title} | ${blog_title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;image/x-icon&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/img/favicon.ico&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;image/x-icon&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/img/favicon.ico&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;shortcut icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/css/reset.css&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;text/css&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/assets/css/theme.css&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;text/css&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- Le HTML5 shim, for IE6-8 support of HTML5 elements --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--[if lt IE 9]&amp;gt;
    &amp;lt;script src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;&lt;/span&gt;
    %if rss_link:
        ${rss_link}
    %endif
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_sidebar_links()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    %for url, text in sidebar_links[lang]:
        % if rel_link(permalink, url) == &quot;#&quot;:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;active&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${text}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %else:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${url}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${text}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endif
    %endfor
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;恭喜你，我们已经设置了我们模板的主框架！&lt;/p&gt;
&lt;p&gt;接下来，我们来看看将要呈现&lt;em&gt;内容&lt;/em&gt;的其它部分。
在我们模板探索的开始，我们看到了Nikola成功建立你的网站最少要包含的模板文件列表。
我们只是完成&lt;em&gt;base.tmpl&lt;/em&gt;，还有哪些呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base.tmpl&lt;/li&gt;
&lt;li&gt;index.tmpl&lt;/li&gt;
&lt;li&gt;post.tmpl&lt;/li&gt;
&lt;li&gt;listing.tmpl&lt;/li&gt;
&lt;li&gt;list.tmpl&lt;/li&gt;
&lt;li&gt;list_post.tmpl&lt;/li&gt;
&lt;li&gt;tags.tmpl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件 &lt;em&gt;index.tmpl&lt;/em&gt; 会呈现出相应的 &lt;em&gt;index.html&lt;/em&gt; 的内容。
在大多数博客的首页包含最新的几篇文章，或者只包含最新的一个帖子，通过下一贴的方式显示旧的帖子。
我选择了后者，滚动20页长的索引页看起来不顺眼。&lt;/p&gt;
&lt;p&gt;所以我的 &lt;em&gt;index.tmpl&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%namespace&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;helper&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;index_helper.tmpl&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;import&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;*&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    %for post in posts:
        %if (loop.first):
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;index-post&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;${post.title(lang)}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;h2&lt;/span&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;post-date&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${post.date.strftime(date_format)} - &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
                ${helper.html_tags(post)}
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;index-post-text&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
                    ${post.text(lang)}
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
                ${helper.html_pager(post)}
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endif
    %endfor
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在顶部我们继承了base.tmpl文件。接下来我们加载了辅助文件，这个辅助文件将包含标签和页面渲染的逻辑。
最后我们呈现出我们的基本标记。因为我只想显示第一篇文章（最新文章），我用Mako的&lt;a href=&quot;http://docs.makotemplates.org/en/latest/runtime.html&quot; title=&quot;Mako的循环逻辑环的更多内容&quot;&gt;循环逻辑&lt;/a&gt;，但只显示循环的第一次迭代。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;index_helper.tmpl&lt;/em&gt; 看起来像这样子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_tags(post)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    % if post.tags:
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;tags&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
            %for tag in post.tags:
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;tag&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${_link('tag', tag, lang)}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${tag}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
            %endfor
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
    % endif
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_pager(post)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;pager&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %if post.prev_post:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;previous&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${post.prev_post.permalink(lang)}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;amp;larr; ${messages[lang][&quot;Previous post&quot;]}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endif
        %if post.next_post:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;next&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${post.next_post.permalink(lang)}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${messages[lang][&quot;Next post&quot;]} &amp;amp;rarr;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endif
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很好，所有的索引中多了一个完成的项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s&gt;base.tmpl&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;index.tmpl&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;post.tmpl&lt;/li&gt;
&lt;li&gt;listing.tmpl&lt;/li&gt;
&lt;li&gt;list.tmpl&lt;/li&gt;
&lt;li&gt;list_post.tmpl&lt;/li&gt;
&lt;li&gt;tags.tmpl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下一逻辑步骤在我们文章本身，专用的单个帖子页。这由 &lt;em&gt;post.tmpl&lt;/em&gt; 处理。
对于这里的每一个文件我们可以看到都是采用相同的模式：他们都是从 &lt;em&gt;base.tmpl&lt;/em&gt; 继承 &lt;em&gt;content&lt;/em&gt; 块。
所以，我们只看一部分。&lt;/p&gt;
&lt;p&gt;下面是我渲染文章的模板：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%namespace&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;helper&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;post_helper.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;postbox&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        ${helper.html_title()}
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;small&lt;/span&gt;&amp;gt;&lt;/span&gt;
            ${messages[lang][&quot;Posted&quot;]}: ${post.date.strftime(date_format)}
            ${helper.html_tags(post)}
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;small&lt;/span&gt;&amp;gt;&lt;/span&gt;
        ${post.text(lang)}
        ${helper.html_pager(post)}
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有helper文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_title()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;${title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
    % if link:
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;'${link}'&lt;/span&gt;&amp;gt;&lt;/span&gt;${messages[lang][&quot;Original site&quot;]}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
    % endif
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_tags(post)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    %if post.tags:
        ${messages[lang][&quot;More posts about&quot;]}
        %for tag in post.tags:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;tag&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${_link('tag', tag, lang)}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;badge badge-info&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${tag}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endfor
    %endif
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;html_pager(post)&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;pager&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %if post.prev_post:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;previous&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${post.prev_post.permalink(lang)}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;amp;larr; ${messages[lang][&quot;Previous post&quot;]}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endif
        %if post.next_post:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;next&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${post.next_post.permalink(lang)}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${messages[lang][&quot;Next post&quot;]} &amp;amp;rarr;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
        %endif
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%def&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，这一切看起来都很简单。我们在helper文件了定义三个块，其中最后两个我们同时在 &lt;em&gt;index_helper.tmpl&lt;/em&gt; 中使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一块渲染标题。&lt;/li&gt;
&lt;li&gt;第二块渲染标签并链接到一个页面，这个页面列出包含该标签的所有文章。&lt;/li&gt;
&lt;li&gt;最后是一个导航可以显示新文章或者老文章。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很简单，对不对？
再划掉一个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s&gt;base.tmpl&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;index.tmpl&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;post.tmpl&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;listing.tmpl&lt;/li&gt;
&lt;li&gt;list.tmpl&lt;/li&gt;
&lt;li&gt;list_post.tmpl&lt;/li&gt;
&lt;li&gt;tags.tmpl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下一个是渲染代码清单的功能，就是我们之前看到的文章，看起来像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;breadcrumb&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        % for link, crumb in crumbs:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${link}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;/ ${crumb}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;
        % endfor
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
    ${code}
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们先呈现出类似于面包屑的分层目录结构的文件，然后我们只是简单的渲染它。再看看！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base.tmpl&lt;/li&gt;
&lt;li&gt;index.tmpl&lt;/li&gt;
&lt;li&gt;post.tmpl&lt;/li&gt;
&lt;li&gt;listing.tmpl&lt;/li&gt;
&lt;li&gt;list.tmpl&lt;/li&gt;
&lt;li&gt;list_post.tmpl&lt;/li&gt;
&lt;li&gt;tags.tmpl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后我们只剩下三个文件， &lt;em&gt;list.tmpl&lt;/em&gt;, &lt;em&gt;list_post.tmpl&lt;/em&gt; 和 &lt;em&gt;tags.tmpl&lt;/em&gt; ，使用几乎相同的模板。
它们之间的主要区别是他们有自己的数据。
&lt;em&gt;list.tmpl&lt;/em&gt; 有 &lt;em&gt;items&lt;/em&gt; 词典提供一般的链接， &lt;em&gt;list_post.tmpl&lt;/em&gt; 得到 &lt;em&gt;posts&lt;/em&gt; 目录包含所有的文章， &lt;em&gt;tags.tmpl&lt;/em&gt; 得到一字典包含所有标签信息。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;list_post.tmpl&lt;/em&gt; 用来按年份来显示文章的列表（当用存档显示的方式浏览）。该模板看起来像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--Body content--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;postbox&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;${title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;unstyled&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
            % for post in posts:
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${post.permalink(lang)}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;[${post.date.strftime(date_format)}] ${post.title(lang)}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
            % endfor
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--End of body content--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个模板没有必要使用helper文件，因为没有这么多的功能。它只呈现一个包含文章标题的无序列表。
当然，你可以让更多从 &lt;em&gt;posts&lt;/em&gt; 中的内容在这里面渲染出来。&lt;/p&gt;
&lt;p&gt;当你对比将看到 &lt;em&gt;list.tmpl&lt;/em&gt; 会发现用相同的代码，只是用 &lt;em&gt;items&lt;/em&gt; 代替 &lt;em&gt;posts&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--Body content--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;postbox&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;${title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;unstyled&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
            % for text, link in items:
                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${link}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${text}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
            % endfor
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--End of body content--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是渲染对你有用户的不同年份列表。&lt;/p&gt;
&lt;p&gt;文件 &lt;em&gt;tags.tmpl&lt;/em&gt; 也是用 &lt;em&gt;items&lt;/em&gt; 保存所有的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%inherit&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;file&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;base.tmpl&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;postbox&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--Body content--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;${title}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;unstyled&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
        % for text, link in items:
            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;li&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;tag&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;${link}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;badge badge-info&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${text}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;
        % endfor
        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;ul&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--End of body content--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;%block&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;呼，我们已经写了所有必要的模板文件。
这意味着现在Nikola有足够的信息来呈现出每一个独立HTML页面。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;测试运行&lt;/h2&gt;
&lt;p&gt;那么，你准备好进入构建的第二阶段了吗？这一次有自己的主题了吗？冲啊！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;$ nikola build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您仍然在另一个终端有Nikola服务器运行，你就可以刷新页面，这样就看到你新的模板。
当然，我们没有写任何CSS，所以一切看起来挺像&lt;a href=&quot;https://duckduckgo.com/?q=css+naked+day&quot; title=&quot;在 DuckDuckGo 中的 css naked day&quot;&gt;CSS Naked Day&lt;/a&gt;（这本身是一个很好的测试）。&lt;/p&gt;
&lt;p&gt;在这篇文章的开头，我们构建了页眉和包含一些CSS文件，这些文件我已经用在Shisaa.jp中。继续修改你的主题风格并正确地链接到这些文件，并重新编译。&lt;/p&gt;
&lt;p&gt;现在你有了一个可以运行的Nikola的网站了！&lt;/p&gt;
&lt;p&gt;我希望我能让你的指尖在建立Nikola网站过程中充满力量。
现在可以进行更多了，我鼓励你去探索更多的功能，如画廊，多种语言，DISQUS一体化，尝试不同的标记语言，…&lt;/p&gt;
&lt;p&gt;和往常一样…感谢你的阅读！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;-&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;很开心陆续花了3天时间翻译完了这篇文章，因英文水平和表达能力有限，有翻译不对的地方或者建议欢迎联系麦客园，同时也欢迎更多喜欢Nikola的Funs一同分享心得，谢谢你的阅读！&lt;/p&gt;
</description></item><item><title>Markdown 语法说明 (简体中文版)</title><link>https://mikecyc.github.io/articles/markdown-syntax-cn/</link><pubDate>Fri, 28 Jun 2013 11:27:46 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/markdown-syntax-cn/</guid><author></author><description>&lt;h2 id=&quot;overview&quot;&gt;概述&lt;/h2&gt;

&lt;h3 id=&quot;philosophy&quot;&gt;宗旨&lt;/h3&gt;

&lt;p&gt;Markdown 的目标是实现「易读易写」。&lt;/p&gt;
&lt;p&gt;可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt;、&lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt;、&lt;a href=&quot;http://textism.com/tools/textile/&quot;&gt;Textile&lt;/a&gt;、&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;reStructuredText&lt;/a&gt;、&lt;a href=&quot;http://www.triptico.com/software/grutatxt.html&quot;&gt;Grutatext&lt;/a&gt; 和 &lt;a href=&quot;http://ettext.taint.org/doc/&quot;&gt;EtText&lt;/a&gt;，而最大灵感来源其实是纯文本电子邮件的格式。&lt;/p&gt;
&lt;p&gt;总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。&lt;/p&gt;
&lt;h3 id=&quot;html&quot;&gt;兼容 HTML&lt;/h3&gt;

&lt;p&gt;Markdown 语法的目标是：成为一种适用于网络的&lt;em&gt;书写&lt;/em&gt;语言。&lt;/p&gt;
&lt;p&gt;Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想&lt;em&gt;不是&lt;/em&gt;要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种&lt;em&gt;发布&lt;/em&gt;的格式，Markdown 是一种&lt;em&gt;书写&lt;/em&gt;的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。&lt;/p&gt;
&lt;p&gt;要制约的只有一些 HTML 区块元素――比如 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;
&lt;p&gt;例子如下，在 Markdown 文件里加上一段 HTML 表格：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是一个普通段落

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

这是另一个普通段落
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的&lt;code&gt;*强调*&lt;/code&gt;会没有效果。&lt;/p&gt;
&lt;p&gt;HTML 的区段（行内）标签如 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。&lt;/p&gt;
&lt;p&gt;和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。&lt;/p&gt;
&lt;h3 id=&quot;autoescape&quot;&gt;特殊字符自动转换&lt;/h3&gt;

&lt;p&gt;在 HTML 文件中，有两个字符需要特殊处理： &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 。 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号用于起始标签，&lt;code&gt;&amp;amp;&lt;/code&gt; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 字符尤其让网络文档编写者受折磨，如果你要打「&lt;code&gt;AT&amp;amp;T&lt;/code&gt;」 ，你必须要写成「&lt;code&gt;AT&amp;amp;amp;T&lt;/code&gt;」。而网址中的 &lt;code&gt;&amp;amp;&lt;/code&gt; 字符也要转换。比如你要链接到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你必须要把网址转换写为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;才能放到链接标签的 &lt;code&gt;href&lt;/code&gt; 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。&lt;/p&gt;
&lt;p&gt;Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &lt;code&gt;&amp;amp;&lt;/code&gt; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &lt;code&gt;&amp;amp;amp&lt;/code&gt;;。&lt;/p&gt;
&lt;p&gt;所以你如果要在文档中插入一个版权符号 &lt;code&gt;©&lt;/code&gt;，你可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp;copy;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 会保留它不动。而若你写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AT&amp;amp;T
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 就会将它转为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AT&amp;amp;amp;T
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似的状况也会发生在 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号上，因为 Markdown 允许 &lt;a href=&quot;#html&quot;&gt;兼容 HTML&lt;/a&gt; ，如果你是把 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 &amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 将会把它转换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 &amp;amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过需要注意的是，code 范围内，不论是行内还是区块， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 两个符号都&lt;em&gt;一定&lt;/em&gt;会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;block&quot;&gt;区块元素&lt;/h2&gt;


&lt;h3 id=&quot;p&quot;&gt;段落和换行&lt;/h3&gt;

&lt;p&gt;一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。&lt;/p&gt;
&lt;p&gt;「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;
&lt;p&gt;如果你&lt;em&gt;确实&lt;/em&gt;想要依赖 Markdown 来插入 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签的话，在插入处先按入两个以上的空格然后回车。&lt;/p&gt;
&lt;p&gt;的确，需要多费点事（多加空格）来产生 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; ，但是简单地「每个换行都转换为 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 &lt;a href=&quot;#blockquote&quot;&gt;区块引用&lt;/a&gt; 和多段落的 &lt;a href=&quot;#list&quot;&gt;列表&lt;/a&gt; 在使用换行来排版的时候，不但更好用，还更方便阅读。&lt;/p&gt;
&lt;h3 id=&quot;header&quot;&gt;标题&lt;/h3&gt;

&lt;p&gt;Markdown 支持两种标题的语法，类 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt; 和类 &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt; 形式。&lt;/p&gt;
&lt;p&gt;类 Setext 形式是用底线的形式，利用 &lt;code&gt;=&lt;/code&gt; （最高阶标题）和 &lt;code&gt;-&lt;/code&gt; （第二阶标题），例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is an H1
=============

This is an H2
-------------
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;任何数量的 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 都可以有效果。&lt;/p&gt;
&lt;p&gt;类 Atx 形式则是在行首插入 1 到 6 个 &lt;code&gt;#&lt;/code&gt; ，对应到标题 1 到 6 阶，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 这是 H1

## 这是 H2

###### 这是 H6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 &lt;code&gt;#&lt;/code&gt;，而行尾的 &lt;code&gt;#&lt;/code&gt; 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;blockquote&quot;&gt;区块引用 Blockquotes&lt;/h3&gt;

&lt;p&gt;Markdown 标记区块引用是使用类似 email 中用 &lt;code&gt;&amp;gt;&lt;/code&gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &lt;code&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt;
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &lt;code&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &lt;code&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is the first level of quoting.
&amp;gt;
&amp;gt; &amp;gt; This is nested blockquote.
&amp;gt;
&amp;gt; Back to the first level.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ## 这是一个标题。
&amp;gt;
&amp;gt; 1.   这是第一行列表项。
&amp;gt; 2.   这是第二行列表项。
&amp;gt;
&amp;gt; 给出一些例子代码：
&amp;gt;
&amp;gt;     return shell_exec(&amp;quot;echo $input | $markdown_script&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择&lt;em&gt;增加引用阶层&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&quot;list&quot;&gt;列表&lt;/h3&gt;

&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;/p&gt;
&lt;p&gt;无序列表使用星号、加号或是减号作为列表标记：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Red
*   Green
*   Blue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等同于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+   Red
+   Green
+   Blue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也等同于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-   Red
-   Green
-   Blue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有序列表则使用数字接着一个英文句点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Bird
2.  McHale
3.  Parish
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;McHale&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Parish&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你的列表标记写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Bird
1.  McHale
1.  Parish
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或甚至是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3. Bird
1. McHale
8. Parish
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。&lt;/p&gt;
&lt;p&gt;如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。&lt;/p&gt;
&lt;p&gt;列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。&lt;/p&gt;
&lt;p&gt;要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果你懒，那也行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;
标签包起来，举例来说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Bird
*   Magic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被转换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Magic&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是这个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Bird

*   Magic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被转换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Bird&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Magic&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You&amp;#39;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要在列表项目内放进引用，那 &lt;code&gt;&amp;gt;&lt;/code&gt; 就需要缩进：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要放代码区块的话，该区块就需要缩进&lt;em&gt;两次&lt;/em&gt;，也就是 8 个空格或是 2 个制表符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   一列表项包含一个列表区块:

        &amp;lt;代码写在这&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，项目列表很可能会不小心产生，像是下面这样的写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1986. What a great season.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;换句话说，也就是在行首出现&lt;em&gt;数字-句点-空白&lt;/em&gt;，要避免这样的状况，你可以在句点前面加上反斜杠。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1986\. What a great season.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;precode&quot;&gt;代码区块&lt;/h3&gt;

&lt;p&gt;和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 标签来把代码区块包起来。&lt;/p&gt;
&lt;p&gt;要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是一个普通段落：

    这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 会转换成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;这是一个普通段落：&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;这是一个代码区块。
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Here is an example of AppleScript:

    tell application &amp;quot;Foo&amp;quot;
        beep
    end tell
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被转换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Here is an example of AppleScript:&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;tell application &amp;quot;Foo&amp;quot;
    beep
end tell
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。&lt;/p&gt;
&lt;p&gt;在代码区块里面， &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;
        &amp;amp;copy; 2004 Foo Corporation
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会被转换为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;div class=&amp;quot;footer&amp;quot;&amp;amp;gt;
    &amp;amp;amp;copy; 2004 Foo Corporation
&amp;amp;lt;/div&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。&lt;/p&gt;
&lt;h3 id=&quot;hr&quot;&gt;分隔线&lt;/h3&gt;

&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* * *

***

*****

- - -

---------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;span&quot;&gt;区段元素&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;链接&lt;/h3&gt;

&lt;p&gt;Markdown 支持两种形式的链接语法： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;两种形式。&lt;/p&gt;
&lt;p&gt;不管是哪一种，链接文字都是用 [方括号] 来标记。&lt;/p&gt;
&lt;p&gt;要建立一个&lt;em&gt;行内式&lt;/em&gt;的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is [an example](http://example.com/ &amp;quot;Title&amp;quot;) inline link.

[This link](http://example.net/) has no title attribute.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会产生：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;a href=&amp;quot;http://example.com/&amp;quot; title=&amp;quot;Title&amp;quot;&amp;gt;
an example&amp;lt;/a&amp;gt; inline link.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;http://example.net/&amp;quot;&amp;gt;This link&amp;lt;/a&amp;gt; has no
title attribute.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你是要链接到同样主机的资源，你可以使用相对路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;See my [About](/about/) page for details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;参考式&lt;/em&gt;的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is [an example][id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你也可以选择性地在两个方括号中间加上一个空格：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is [an example] [id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着，在文件的任意处，你可以把这个标记的链接内容定义出来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: http://example.com/  &amp;quot;Optional Title Here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;链接内容定义的形式为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字&lt;/li&gt;
&lt;li&gt;接着一个冒号&lt;/li&gt;
&lt;li&gt;接着一个以上的空格或制表符&lt;/li&gt;
&lt;li&gt;接着链接的网址&lt;/li&gt;
&lt;li&gt;选择性地接着 title 内容，可以用单引号、双引号或是括弧包着&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面这三种链接的定义都是相同：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[foo]: http://example.com/  &amp;quot;Optional Title Here&amp;quot;
[foo]: http://example.com/  &amp;#39;Optional Title Here&amp;#39;
[foo]: http://example.com/  (Optional Title Here)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;请注意：&lt;/strong&gt;有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。&lt;/p&gt;
&lt;p&gt;链接网址也可以用方括号包起来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: &amp;lt;http://example.com/&amp;gt;  &amp;quot;Optional Title Here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: http://example.com/longish/path/to/resource/here
    &amp;quot;Optional Title Here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。&lt;/p&gt;
&lt;p&gt;链接辨别标签可以有字母、数字、空白和标点符号，但是并&lt;em&gt;不&lt;/em&gt;区分大小写，因此下面两个链接是一样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[link text][a]
[link text][A]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;隐式链接标记&lt;/em&gt;功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Google][]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后定义链接内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Google]: http://google.com/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Visit [Daring Fireball][] for more information.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后接着定义链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Daring Fireball]: http://daringfireball.net/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。&lt;/p&gt;
&lt;p&gt;下面是一个参考式链接的范例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &amp;quot;Google&amp;quot;
  [2]: http://search.yahoo.com/  &amp;quot;Yahoo Search&amp;quot;
  [3]: http://search.msn.com/    &amp;quot;MSN Search&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果改成用链接名称的方式写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &amp;quot;Google&amp;quot;
  [yahoo]:  http://search.yahoo.com/  &amp;quot;Yahoo Search&amp;quot;
  [msn]:    http://search.msn.com/    &amp;quot;MSN Search&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面两种写法都会产生下面的 HTML。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&amp;quot;http://google.com/&amp;quot;
title=&amp;quot;Google&amp;quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from
&amp;lt;a href=&amp;quot;http://search.yahoo.com/&amp;quot; title=&amp;quot;Yahoo Search&amp;quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt;
or &amp;lt;a href=&amp;quot;http://search.msn.com/&amp;quot; title=&amp;quot;MSN Search&amp;quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google](http://google.com/ &amp;quot;Google&amp;quot;)
than from [Yahoo](http://search.yahoo.com/ &amp;quot;Yahoo Search&amp;quot;) or
[MSN](http://search.msn.com/ &amp;quot;MSN Search&amp;quot;).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。&lt;/p&gt;
&lt;p&gt;使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。&lt;/p&gt;
&lt;h3 id=&quot;em&quot;&gt;强调&lt;/h3&gt;

&lt;p&gt;Markdown 使用星号（&lt;code&gt;*&lt;/code&gt;）和底线（&lt;code&gt;_&lt;/code&gt;）作为标记强调字词的符号，被 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 包围的字词会被转成用 &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签包围，用两个 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 包起来的话，则会被转成 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会转成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;em&amp;gt;single asterisks&amp;lt;/em&amp;gt;

&amp;lt;em&amp;gt;single underscores&amp;lt;/em&amp;gt;

&amp;lt;strong&amp;gt;double asterisks&amp;lt;/strong&amp;gt;

&amp;lt;strong&amp;gt;double underscores&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。&lt;/p&gt;
&lt;p&gt;强调也可以直接插在文字中间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;un*frigging*believable
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是&lt;strong&gt;如果你的 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;_&lt;/code&gt; 两边都有空白的话，它们就只会被当成普通的符号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\*this text is surrounded by literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;code&quot;&gt;代码&lt;/h3&gt;

&lt;p&gt;如果要标记一小段行内代码，你可以用反引号把它包起来（&lt;code&gt;` &lt;/code&gt;），例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Use the `printf()` function.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会产生：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Use the &amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt; function.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;``There is a literal backtick (`) here.``
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段语法会产生：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;There is a literal backtick (`) here.&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会产生：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;A single backtick in a code span: &amp;lt;code&amp;gt;`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;A backtick-delimited string in a code span: &amp;lt;code&amp;gt;`foo`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在代码区段内，&lt;code&gt;&amp;amp;&lt;/code&gt; 和方括号&lt;strong&gt;都&lt;/strong&gt;会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please don&amp;#39;t use any `&amp;lt;blink&amp;gt;` tags.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;转为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Please don&amp;#39;t use any &amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你也可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`&amp;amp;#8212;` is the decimal-encoded equivalent of `&amp;amp;mdash;`.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以产生：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt; is the decimal-encoded
equivalent of &amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;img&quot;&gt;图片&lt;/h3&gt;

&lt;p&gt;很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。&lt;/p&gt;
&lt;p&gt;Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;行内式的图片语法看起来像是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &amp;quot;Optional title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;详细叙述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个惊叹号 &lt;code&gt;!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接着一个方括号，里面放上图片的替代文字&lt;/li&gt;
&lt;li&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 ‘title’ 文字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考式的图片语法则长得像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![Alt text][id]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: url/to/image  &amp;quot;Optional title attribute&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;misc&quot;&gt;其它&lt;/h2&gt;

&lt;h3 id=&quot;autolink&quot;&gt;自动链接&lt;/h3&gt;

&lt;p&gt;Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://example.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 会转为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;http://example.com/&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;address@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 会转成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;amp;#x6D;&amp;amp;#x61;i&amp;amp;#x6C;&amp;amp;#x74;&amp;amp;#x6F;:&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;
&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;
&amp;amp;#109;&amp;quot;&amp;gt;&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;
&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;&amp;amp;#109;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在浏览器里面，这段字串（其实是 &lt;code&gt;&amp;lt;a href=&amp;quot;mailto:address@example.com&amp;quot;&amp;gt;address@example.com&amp;lt;/a&amp;gt;&lt;/code&gt;）会变成一个可以点击的「address@example.com」链接。&lt;/p&gt;
&lt;p&gt;（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）&lt;/p&gt;
&lt;h3 id=&quot;backslash&quot;&gt;反斜杠&lt;/h3&gt;

&lt;p&gt;Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签），你可以在星号的前面加上反斜杠：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\*literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;acknowledgement&quot;&gt;感谢&lt;/h2&gt;

&lt;p&gt;感谢 &lt;a href=&quot;https://twitter.com/#!/leafy7382&quot;&gt;leafy7382&lt;/a&gt; 协助翻译，&lt;a href=&quot;http://iamhlb.com/&quot;&gt;hlb&lt;/a&gt;、&lt;a href=&quot;http://twitter.com/randylien&quot;&gt;Randylien&lt;/a&gt; 帮忙润稿，&lt;a href=&quot;https://twitter.com/#!/ethantw&quot;&gt;ethantw&lt;/a&gt; 的&lt;a href=&quot;http://ethantw.net/projects/han/&quot;&gt;汉字标准格式・CSS Reset&lt;/a&gt;， &lt;a href=&quot;http://kidwm.net/&quot;&gt;WM&lt;/a&gt; 回报文字错误。&lt;/p&gt;
&lt;p&gt;感谢 &lt;a href=&quot;https://github.com/fenprace&quot;&gt;fenprace&lt;/a&gt;，&lt;a href=&quot;https://github.com/addv&quot;&gt;addv&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;editor&quot;&gt;Markdown 免费编辑器&lt;/h2&gt;

&lt;p&gt;Windows 平台&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://markdownpad.com/&quot;&gt;MarkdownPad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code52.org/DownmarkerWPF/&quot;&gt;MarkPad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 平台&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://sourceforge.net/p/retext/home/ReText/&quot;&gt;ReText&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mac 平台&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://mouapp.com/&quot;&gt;Mou&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在线编辑器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://markable.in/&quot;&gt;Markable.in&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dillinger.io/&quot;&gt;Dillinger.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器插件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog&quot;&gt;MaDe&lt;/a&gt; (Chrome)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;高级应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.sublimetext.com/2&quot;&gt;Sublime Text 2&lt;/a&gt; + &lt;a href=&quot;http://ttscoff.github.com/MarkdownEditing/&quot;&gt;MarkdownEditing&lt;/a&gt; / &lt;a href=&quot;http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/&quot;&gt;教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*** 如有更好的 Markdown 免费编辑器推荐，请到&lt;a href=&quot;https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1&quot;&gt;这里反馈&lt;/a&gt;，谢谢！&lt;/p&gt;
</description></item><item><title>基督徒生活十大守则</title><link>https://mikecyc.github.io/articles/ten-christian-life-code/</link><pubDate>Fri, 08 Mar 2013 13:52:05 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/ten-christian-life-code/</guid><author></author><description>&lt;p&gt;&lt;strong&gt;你们愿意人怎样待你们，你们也要怎样待人。——路加福音六章三十一节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是玩游戏、开车或者做个可口的小菜，要成功又安全，一定得守某些规则。&lt;/p&gt;
&lt;p&gt;我清楚记得，几年前，家宅附近马路扩大，从两线行车变成四线。在扩建期间，马路上划的那些白线没有了。有一晚，两辆车迎头相撞，死了五个人；原因是那条分开左右行车道的中央白线没有了，驾车的人失去了可循的“规则”。&lt;/p&gt;
&lt;p&gt;圣经教训我们，基督徒有个不断生长的生命。你重生 了，生在天父的家里。我与妻子露丝现有孙儿女十六人，每个孩子都是我们的珍宝；天父眼中的你也是这样。他盼望你在基督里长大成人。要是你长来长去仍是婴儿 模样，成了一个灵性上的侏儒，那不仅违反自然律，也不合上主的旨意。《彼得后书》三章十八节劝勉基督徒一定要有长进，也就是灵性生命应该不断长大，恩典和 知识日有增加，做个成长的基督徒。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;基督徒要灵性健康，生长顺畅，不断长进，一定得遵行某些守则。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则一：天天阅读圣经。&lt;/h3&gt;
&lt;p&gt;读经是基督徒享有的一大权利。灵性生命象肉体生命 一样需要饮食，我们把这饮食叫做灵粮。灵粮从那里去找？灵粮也就是上主的话语，储存在圣经中。圣经把基督显明给了我们。而基督就是我们生命的粮，能满足我 们灵命的饥饿；基督也是生命的活水，能满足我干渴的心。基督徒的灵命假若没有了每日粮食的供应，就会因缺乏营养失掉活力。圣经说：&lt;code&gt;“爱慕那纯净的灵 奶，……叫你们因此渐长”（彼前二2）&lt;/code&gt;。要阅读圣经、查考圣经、背诵圣经。须知作基督徒所遭逢的困难，百分之九十九来自不经常研读圣经。&lt;/p&gt;
&lt;p&gt;考古学家要是发现了成吉思汗或者亚历山大大帝的 日记手稿、或者埃及女王克里奥佩拉的情书、又或者太空人在月球上找到一部神秘的文稿，这些文稿要是印成书，全球的书店一定门限为穿，人人都会抢着买一本来 读。可是，现在有一本书，是上主自己写给人读的，许多自称为文明人的人却故意不理会，甚且抵毁它。这真不可思议！&lt;/p&gt;
&lt;p&gt;今天世界上有些地方，享受不到我们所享有的阅读 圣经和一齐查考圣经的自由。事实上，大部份的地区，已存在对上主话语的饥渴荒。我记得中国有位音乐家，他是读了一位不相识的人塞在他手里的几页撕下来的圣 经而归主，而灵命得到力量的。有些信徒给关进监狱，在那里挨劳改，过了二、三十年才获释；出来时心脑俱健，对整他们的人毫无恶言，一片宽恕。&lt;/p&gt;
&lt;p&gt;上主话语的力量也可以从另一件事看出：美国有间精神病院，里面住了一位年轻的病人。他写信给我，希望送他一本圣经。他后来的痊愈和健康，追溯原因，和阅读这本圣经有不可分的关系。他现在已经结婚，成家立业。&lt;/p&gt;
&lt;p&gt;读圣经时，不要只求良心之所安，粗略地读个一两章 为满足。读圣经须把上主的话语藏在心里；好好消化圣经一小段，对灵性的益处，远远大过匆匆读一大段。要是读时不明白，千万别灰心。有的人藉口圣经难懂不读 它；无论什么书，若不去读，都是难懂的。先读圣经易懂的部份；没有谁第一天便给婴儿吃牛排，应先喂他牛奶。&lt;/p&gt;
&lt;p&gt;我建议你先读《约翰福音》。读的时候圣灵会帮助你，会为你解开难明白的地方，揭示隐藏的意义。读过的经文若不能全记住，或者不能全都了解，别灰心；重要的是继续读下去。其实，读经本身就带有净化心灵的作用。阅读圣经，天天读，不可中断。&lt;/p&gt;
&lt;p&gt;熟背圣经节的好处，是遇到没有圣经在身边时（例如夜晚睡不着、开车、旅行、或者临时须作重要决定），可以记起上主的话，用来安慰、鼓励、引领和指正你；这些熟记的经节随时可以帮助你；能背熟多少便背多少。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则二：学习祷告的秘诀。&lt;/h3&gt;
&lt;p&gt;你初作祷告可能结结巴巴，拙嘴笨舌，词不达意。但住在你里头的圣灵会帮助你，教导你。你祷告，上主一定有回应：有时是“可以”，有时是“不可以”，有时是“稍等”，但祈求总有回答。&lt;/p&gt;
&lt;p&gt;祷告是把意思传达出去。初生婴儿最早的“语言”是对他父母的回应。他“说”并非要什么。他看见父亲、母亲对他笑，他便投以微笑；对他讲，他便咿啊个不停。一家大小看见了无不笑嗬嗬。基督徒要是能开口祷告，向天父说话，你想他该有多大的快乐？&lt;/p&gt;
&lt;p&gt;你若向天父求，应该在“让你的旨意完成”的条件下提出。&lt;code&gt;“要以耶和华为乐，他就将你心里所求的赐给你”（诗三十七4）&lt;/code&gt;。要心里所想的得到满足，先要心里以上主为乐；心里能以上主为乐，自会如何导你求，上主也能应允你的所求。&lt;/p&gt;
&lt;p&gt;我们随时随地都可以祷告。在家里打扫、在办公厅里工作、在体育场、甚至在监狱中，都可以祷告。无论你在何处祷告，上主都垂听。我们有位已判死刑的朋友，他每天清晨四至六点钟为我们的布道事工祷告。这件事常常令我们得到无比的鼓舞，奋勇向前。&lt;/p&gt;
&lt;p&gt;试把祷告纳入生活的轨道中，和读经研经配合。来度 健康的基督徒生活。圣经说，“当不住的祷告。”要是你一天当中规定有几个祷告时刻，在两次祷告时刻之间，你的生命便能在不知不觉中为祷告所充满。清早起 床，低下头说几句惯说的祷词，是不够的。每天一定要有指定的时刻与上主亲近。对家务繁忙的母亲、对生活十分忙碌的人来说，这也许办不到。遇到这情形就可以 用“不住的祷告”的方法，一边工作一边祷告。我们可以随时随地向天父说话。&lt;/p&gt;
&lt;p&gt;你向前走，每一步都会遇到魔鬼的阻力；他会令婴 儿啼哭、电话铃响、敲门声，……许许多多的干扰。但不要怕，守住你的祷告时刻；不消多久，你便会发现，这一天当中的祷告时刻是生活中最大的快乐。生活要是 没有了每天经常的祈祷，会觉得如处沙漠，灰暗失望，毫无成就。没有经常的祈祷，你永远得不到天父要你享有的内心的平安。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则三：常常倚靠圣灵的能力。&lt;/h3&gt;
&lt;p&gt;主基督藉着圣灵住在你里头；你的身体是三位一体中 的圣灵的居所。别把他当仆人，有需要时才呼唤他；应求他住在你心里，一切交托给他，求他成为你生命的主。告诉他你是何等的软弱、无助、浮沉不定、站立不 稳。你不妨自己站开，让出位来，听由圣灵为你的生活作选择、作决定。我们都知道圣灵为我们祷告（罗八章）；我们再软弱，有他代求，这是何等大的安慰。&lt;/p&gt;
&lt;p&gt;要度基督徒的生活，单靠自己的力量是办不到的； 但圣灵能托住你、支持你。假若你挣扎、抵抗、拳打脚踢，他想托住你也托不住。你应该安静放松自己；在主里面，把心里的紧张、情结通通解开，完全倚靠他。遇 有重大问题，不要担心，不要忧虑，由他来为你作决定。不要为明天忧虑，他是掌管明天的主，他知道始也知道终。不要为生活的所需担忧，他会供应。一个真正得 胜的基督徒，尽管面对忧虑、不安与紧张，因深信这一切都在上主的手中，他能驾驭，到最后都能胜利克服。倚靠圣灵，不但许多忧虑和内心的紧张与不安可以祛 除，连许多身体与精神的病痛也会消失。不问我们的困难多大，环境多坏，总应记得一句话：“耶稣能胜了又胜”。（这是一位在纳粹统治下关进集中营的荷兰女信 徒彭柯丽最爱说的一句话。主基督帮助她战胜一切困难，胜利逃脱魔掌，终生见证主。）&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则四：经常参加聚会。&lt;/h3&gt;
&lt;p&gt;基督徒看重信徒间的交通。跟随基督是学效他的慈爱、公义与服侍人的榜样。要做到这些，必须在人际关系中具体表现出来；而这种机会得在教会中去找。&lt;/p&gt;
&lt;p&gt;教会有看得见的和看不见的两种。看不见的教会由古往今来的忠心信徒构成，范围遍全球；看得见的教会包括各种宗派。圣经告诉我们，&lt;code&gt;“不可停止聚会……”（来十25）&lt;/code&gt;。基督徒需要团契生活，可以有灵里的交通契合。&lt;/p&gt;
&lt;p&gt;看得见的教会是基督设立在地上的组织，是我们集合 敬拜上主的地方。我们在教会里学习他的道，与基督徒有交通。圣经把教会叫做“圣洁的国度”、“属上主的子民”、“上主的家”、“主的圣殿”、“上主的居 所”、“基督的身体”。这些都是象征性的说法，用具体有形的事物来描写教会属灵的存在。&lt;/p&gt;
&lt;p&gt;参加教会的崇拜是必须的，无他物可以取代。你若 是基督真正的信徒，一定会觉得许多肤浅的藉口十分可笑，诸如说天气太热太冷，或者说落雨、下雪之类。真正跟随基督的人，不应以此为理由不赴礼拜。许多人说 主日可以呆在家里，在自己的心里敬拜主。这不是上主所要求于我们的，他要求我们有完全的敬拜，这是他的权利。他不只造了我们的心灵，也造了我们的身体；因 此，我们的身体和心灵都应该参加主日崇拜，完完全全地敬拜他。&lt;/p&gt;
&lt;p&gt;近年来有“电子教会”出现，通过广播和电视播送聚会和讲道节目，许多在医院、老人院、甚至监狱中的人，可以有机会参加敬拜。&lt;/p&gt;
&lt;p&gt;但也有人认为留在家里收听、收看广播与电视播送的 讲道，可以替代聚会。这是不够的。你参加礼拜不只是为了听道；你去教会是为了敬拜上主，与其他信徒有交通，得到事奉的机会。不在教会中尽心尽意事奉，不能 做个又成功又快乐的基督徒。教会是你事奉的地方；基督拯救我们，要求我们有事奉。喜乐的基督徒是有事奉的基督徒。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则五：作个有见证的基督徒。&lt;/h3&gt;
&lt;p&gt;要是你能忠忠实实地做到前述四大守则，你也就自自然然能够见证基督，就好象给一个杯子不断倒入水，一定会满溢出来。&lt;/p&gt;
&lt;p&gt;不久前有人问我：在用生活见证主和用主的话见证主 之间，那个更重要。答案是：“请问飞机的左翼和右翼，那个更重要？”我觉得这个答复很聪明。有天我开车和几位传教士一道去用午餐，我把这答案告诉他们，其 中一位忍不住说话了。她说：“你答得很聪明，可是并不真实。”我听了觉得很奇怪，要她解释。她说：“全本圣经都告诉我们，上主应许赐福的是他的话语，不是 我们的生活。圣经说：‘我口所出的话……决不徒然返回，却要成就……。得我话的人，可以诚实讲说我的话；糠秕怎能与麦子比较呢？这是耶和华说的（赛五五 11；耶二十三28）’。”我明白她说的是真理。我们如何生活，得向上主负责，他应许祝福的是他的话语。这就说明了为什么葡萄牙的一位军医，踏着泥泞的道 路回家，发现皮鞋上沾了一张纸，把它撕脱，原来是一页圣经。他读了上面的话，归信了基督。&lt;/p&gt;
&lt;p&gt;基督徒是万王之王特派的大使，应把我们的旌旗高高挂在大使馆上。要是美国驻苏联大使因为美国旗在那里不受欢迎，把国旗卸了下来，这样的大使一定很快会被召回国，因他无资格代表美国。&lt;/p&gt;
&lt;p&gt;我们做基督徒的假若不能把我们的旌旗高高挂在屋顶上，挂在办公厅、商店或者校园里，我们也不够资格做基督的大使。我们一定得站稳立场，让周围的人都知道我们是基督徒，我们是他的见证人。&lt;/p&gt;
&lt;p&gt;见证基督有两种方法，用生活来见证和用上主的话语来见证。这二者可以同时使用，并行不悖。我们回转得到新生命之后，上主要我们为他的救赎大恩和大能作见证。我们应作基督的敢死队，作随时可以应召打仗的精兵。&lt;/p&gt;
&lt;p&gt;主基督说，&lt;code&gt;“凡在人面前认我的，我在我天上的父面 前也必认他”（太十32）&lt;/code&gt;。《使徒行传》二十八章二十三节记有一幅感人的图画：保罗虽然身系囹圄，被囚罗马，却从早到晚向来看他的人讲论主耶稣的真道。我 们也应该每天为主工作，人家看见了会说：“看哪，有一个撒种的出去撒种了。”美国西联电报公司的送信差，生活极之枯燥，他们的唯一工作就是把收到的电报送 给收件人。他们有时也许不愿送，因为电报里或许是坏消息，叫收到的人十分不开心；但他们不能在中途停下来，拆开电报，改动几个字，不报坏消息；他们的责任就是送电报。&lt;/p&gt;
&lt;p&gt;我们做基督徒的手里握有上主的话，我们的三军总 司令的命令是：“去！把这个消息带给走在死亡路上的世人。”有的人不理会这信息，有的人把这电报撕毁，换上他们自己的话；有的只接受其中一部份；有的则告 诉人说，主基督说的话并不当真；还有的说，基督没有真的写过这些信息，都是误解信息内容的凡人写的。&lt;/p&gt;
&lt;p&gt;让我们记住，使徒保罗在许多个世纪以前，曾劝勉基督徒，只教导上主的话语。应记住我们是在撒种，有的撒在人来人往的路上，有的撒在荆棘丛中。不管怎样，我们必须继续撒下去，不可因为有些泥土看去不利生长便停止工作。&lt;/p&gt;
&lt;p&gt;我们手里拿着灯，一定要让灯光照耀。在漆黑一片的世界里，这光看去小如蜡烛，但是我的责任就是让光照出去。&lt;/p&gt;
&lt;p&gt;我们在吹号。战争的喧哗声里，我们的号声几乎给淹没；但是我们一定得吹，使处在危险中的人能警醒。&lt;/p&gt;
&lt;p&gt;我们在燃点一堆火，在这充满仇恨与自私的冷酷世界里，我们的小小火堆看来于事无补，但我们有责任让火堆燃烧下去。&lt;/p&gt;
&lt;p&gt;我们用锤击打，除了震得手痛之外，好象毫不起作用。但是我们得不断锤下去。有人问一位石匠，靠什么力量把巨石打裂。石匠回答说：“靠第一锤，靠最后一锤，靠两锤之间的每一锤。”&lt;/p&gt;
&lt;p&gt;我们有饥饿的世界所需要的粮食。世人忙着抢别的东西填饱肚子，偏偏不要可以止饥的生命的粮；但我们应该不断把这粮供应世界，供给饥饿的灵魂。&lt;/p&gt;
&lt;p&gt;我们有口渴的人需要的活水，应该继续大声呼喊：“来！口渴的人都当来，愿意的都可以白白取生命的水喝。”有时候他们来不了，我们应把水送到他们那里。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则六：必须有耐力绝不放弃努力。&lt;/h3&gt;
&lt;p&gt;我们得有耐力，绝不可以放弃努力，当不断使用上主的话语。&lt;/p&gt;
&lt;p&gt;主耶稣讲撒种人的比喻时告诉我们，我们撒的种子有 不少会落在肥土里，结实百倍。我们应该做基督的忠心见证人。人间最震荡心灵的经验，是为主基督赢得失去的灵魂归来。我个人有幸能领别人认识基督，每逢知道 有人听到福音、接受了基督，因他的恩典而有了全新的生命时，我内心总不能不感到雀跃，这比得到世上所有的金钱还快乐。世界上没有任何福气、任何体验、任何 爱情故事，能和成功领人归向基督的喜乐相比。&lt;/p&gt;
&lt;p&gt;圣经说：&lt;code&gt;“有智慧的必能得人。”（箴十一30）&lt;/code&gt;。又说：&lt;code&gt;“智慧人必发光，如同天上的光；那使多人归义的，必发光如星，直到永永远远”（但十二3）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;“你们是世上的盐”（太五13）&lt;/code&gt;，盐能令人口渴。你的生活样式能够令人家见到后也渴望得到生命的水吗？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;“你们若有彼此相爱的心，众人因此就认出你们是我 的门徒了”。（约十三35）&lt;/code&gt;。在新约圣经的另外一个地方，我们也读到同样的话：“亲爱的弟兄阿！我们应当彼此相爱；因为爱是从神来的；凡有爱心的，都是由 神而生，并且认识神。没有爱心的，就不认识神；因为神就是爱。神差他独生子到世间来，使我们藉着他得生，神爱我们的心在此就显明了”（约壹四7一10）。 爱人并不等于说同意被爱者的所作所为。要是上主要等到能同意我们的所作所为才让自己的儿子来救赎我们，我们今天的处境会是个什么样子？&lt;/p&gt;
&lt;p&gt;上主给他子女的一切恩赐中，最大的是爱。圣灵所结的一切果子中，首先是爱。&lt;/p&gt;
&lt;p&gt;圣经告诉我们，跟随基督的人应彼此相爱，象上主爱 我们一样。他爱我们甚至差他的儿子为我们死在十字架上。圣经说，什么时候我们来到基督前，什么时候他就给我们那伟大非凡的爱，藉着圣灵把他的大爱充满我们 的心灵。最能证明我们是基督徒的，就是我们彼此相爱的事实。要是我们能在初作基督徒时就学到彼此相爱的秘诀，我们的基督徒生活距离圆满、幸福已经不远了。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则七：作个顺服的基督徒。&lt;/h3&gt;
&lt;p&gt;在人生中作任何选择时，应让基督居首位。让他作我们的主。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则八：学习怎样对付试探。&lt;/h3&gt;
&lt;p&gt;我们在前面说过，人遇试 探是很自然的事。试探本身并非罪，向试探投降才是罪。上主决不试探我们，他准许有试探的存在，是为了考验我们。魔鬼才试探人。我们应这样正确认识试探。应 付试探的一个方法是引用圣经对付那试探者，他听到后总是逃之夭夭，因为他在上主的话语前立不住脚。&lt;/p&gt;
&lt;p&gt;主耶稣在旷野受试探时，抵抗的唯一力量来源是上主的话。他用“经上记着说”一连三次。&lt;/p&gt;
&lt;p&gt;因此，对付魔鬼的办法也是运用上主的话语。你只须说：“主这样说”，他就会飞逃，同时让基督藉着圣灵为你争战。应象那个有信心的女孩子说的方法：“每当我听到魔鬼敲门，我就请主耶稣去应门。”&lt;/p&gt;
&lt;p&gt;人人都有遇到试探的时候，不过有的人向试探妥协，他们好象以受试探为乐。拿起扫帚追老鼠，老鼠的眼睛不会望住扫把，它会找个洞来躲。别把试探当儿戏，张开双眼望住它；应该注视基督，他才是我们避难的磐石。&lt;/p&gt;
&lt;p&gt;我有一次问一位陆军军官，在战场上，在勇敢与服从之间，他会挑选那一件。他毫不迟疑地回答：“服从！” 上主看重人的服从。要服从，必须熟悉他的命令，这是必须研读圣经的又一原因。圣经是你的指南针和守则；上主怎样命令，你便照样去做。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则九：作个完美无缺的基督徒。&lt;/h3&gt;
&lt;p&gt;有人说得好：“有些基督徒心里只有天上的事，他们在地上一点用也没有。”&lt;/p&gt;
&lt;p&gt;圣经教导我们要和罪断绝关系，但圣经没有要我们做 个反常、怪诞的人。我们应该带着和气、见义勇为、待人以礼、身体洁净、心灵纯洁、仪态大方、谦卑和蔼；不可阿谀谄媚、道人长短、讲阴毒的话、找挑逗性的消 遣，这些都应避之如蛇蝎。我们的外表应整洁动人，服饰趣味高尚。切莫趋向时尚，走极端。我们的生活、言谈、举止，应该使福音信息得到称赞，令别人见到愿意 来听信福音。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;守则十：生活不为环境所囿。&lt;/h3&gt;
&lt;p&gt;上主造了你，就希望你是你的那个样子。他把你放在适合你的地方。你以真我来侍奉，最能侍奉他、荣耀他。有的人这山望见那山高，总不满足于自己的现状，做白日梦，盼望来个大翻身，找种种理由来为自己的梦想辩护；眼前已有的好形势、好机会，反轻轻错过。&lt;/p&gt;
&lt;p&gt;应该记起使徒保罗说的话：“我却不以性命为念，也 不看为宝贵”（徒二十24）。他说，他已学会了怎样处丰富，怎样处贫贱。他已学会了怎样做个十足十的基督徒，即令在囹圄中也是如此。别让环境来左右你；无 论环境如何，都能存感恩的心生活。心里总记得：有主基督自己与你我同在。&lt;/p&gt;
&lt;p&gt;这里所说的十件事看似简单，但若能—一遵守，会有意想不到的功效；许许多多人的生活可为此作见证。只要你肯忠实、正当地遵行，就能得到灵里的平安、内心的宁静、个人的快乐和家庭的幸福。你也就真正学会秘诀，度称心满意的生活。&lt;/p&gt;
</description></item><item><title>理解iOS中的touch事件</title><link>https://mikecyc.github.io/articles/how-mobile-safari-touch-event-works/</link><pubDate>Tue, 13 Mar 2012 09:22:03 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/how-mobile-safari-touch-event-works/</guid><author></author><description>&lt;p&gt;touch事件是iOS中最重要的事件。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;Apple的官方文档&lt;a href=&quot;http://17.254.2.129/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html&quot;&gt;Handling Events&lt;/a&gt;和 &lt;a href=&quot;http://developer.apple.com/library/safari/#documentation/InternetWeb/Conceptual/SafariVisualEffectsProgGuide/Introduction/Introduction.html&quot;&gt;Safari CSS Visual Effects Guide&lt;/a&gt;是很好的开发指南，但是里面的内容显然是针对初学者的，我在这里补充一下。&lt;/p&gt;
&lt;p&gt;另外，Apple开发者中心有很多不错的HTML5教程与资源，例如HTML5离线存储，CSS动画，CSS 3D变换等，有兴趣的可以了解一下。 &lt;a href=&quot;http://developer.apple.com/library/safari/navigation/&quot;&gt;http://developer.apple.com/library/safari/navigation/&lt;/a&gt;&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;h2 id=&quot;-touch-&quot;&gt;二、监听touch事件&lt;/h2&gt;
&lt;p&gt;最简单的办法就是，使用&lt;code&gt;element.addEventListener(touchevent,handler,usercapture)&lt;/code&gt;来捕捉事件。touch事件的类型有&lt;code&gt;touchstart&lt;/code&gt; , &lt;code&gt;touchmove&lt;/code&gt; , &lt;code&gt;touchend&lt;/code&gt; , &lt;code&gt;touchcancel&lt;/code&gt;。在实际使用中，如果你比较习惯模块式开发，你可以使用如下方式捕捉事件，显得更”优雅”。&lt;/p&gt;
&lt;h2 id=&quot;-touch-&quot;&gt;三、touch事件的属性&lt;/h2&gt;
&lt;p&gt;touch事件的重要属性有以下几个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clientX&lt;/code&gt;:X轴坐标，相对于viewport，除去滚动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientY&lt;/code&gt;:轴坐标，相对于viewport，除去滚动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screenX&lt;/code&gt;:X轴坐标，相对于显示器屏幕。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screenY&lt;/code&gt;:Y轴坐标，相对于显示器屏幕。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pageX&lt;/code&gt;:X轴坐标，相对于HTML文档，包括滚动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pageY&lt;/code&gt;:Y轴坐标，相对于HTML文档，包括滚动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt;:导致此事件发生的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;identifier&lt;/code&gt;:事件的唯一内部ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;-&quot;&gt;四、多点触摸的奥秘&lt;/h2&gt;
&lt;p&gt;本文的重点在于此，虽然iOS中提供了&lt;code&gt;gesture event&lt;/code&gt;，但是如果我们需要定制自己的手势，还要深入进行研究。touchevent有如下三个属性，记录了从手指接触屏幕，到离开屏幕的全部过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e.touches&lt;/code&gt;:保存你每一个手指落到屏幕上导致的touch事件的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e.targetTouches&lt;/code&gt;:只保存手指落到同一个元素上导致的touch事件的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e.changedTouches&lt;/code&gt;:保存导致touch事件发生改变的touch事件信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;-&quot;&gt;五、实例操作&lt;/h2&gt;
&lt;p&gt;看到这里你可能完全迷糊了，没关系，亲手体验一下下面的例子就明白这三个属性是如何协同工作的了，如果你使用iOS系统，可以使用手指操作下面的白色区域，仔细观察一下，就明白了。&lt;/p&gt;
&lt;div class=&quot;alert alert-info&quot;&gt;注意：只有手机浏览器上才能看到结果。&lt;/div&gt;

&lt;p&gt;&lt;div id=&quot;toucheventsample&quot; style=&quot;position:relative;width:100%;height:400px;background:white;border:1px solid #CCC;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;div id=&quot;tracer&quot; style=&quot;font-family:Helvetica;font-size:12px;position:absolute;top:15px;left:15px;color:red;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;script&gt;
(function(){

    var uid = 0;

    function imageViewer( el ){
        var self = this;
        this.uid = ++uid;

        this.scale = 1.0;
        this.rotation = 0;
        this.element = el;
        this.wrapper = this.element.parentNode;
        this.element.addEventListener(&quot;touchstart&quot;,this,false);
        this.element.addEventListener(&quot;touchmove&quot;,this,false);
        this.element.addEventListener(&quot;touchend&quot;,this,false);
    }

    function toStr( e ){
        var s = '';
        for( var i=0,l=e.touches.length;i&lt;l;i++ ){
            s = s + &quot;e.touches[&quot;+i+&quot;](clientX,clientY)&quot;+&quot;(&quot;+e.touches[i].clientX+&quot;,&quot;+e.touches[i].clientY+&quot;)&quot;;
            s = s + &quot;&lt;br/&gt;&quot;;
        }
        s += &quot;&lt;hr/&gt;&quot;
        for( var i=0,l=e.targetTouches.length;i&lt;l;i++ ){
            s = s + &quot;e.targetTouches[&quot;+i+&quot;](clientX,clientY)&quot;+&quot;(&quot;+e.targetTouches[i].clientX+&quot;,&quot;+e.targetTouches[i].clientY+&quot;)&quot;;
            s = s + &quot;&lt;br/&gt;&quot;;
        }
        s += &quot;&lt;hr/&gt;&quot;
        for( var i=0,l=e.changedTouches.length;i&lt;l;i++ ){
            s = s + &quot;e.changedTouches[&quot;+i+&quot;](clientX,clientY)&quot;+&quot;(&quot;+e.changedTouches[i].clientX+&quot;,&quot;+e.changedTouches[i].clientY+&quot;)&quot;;
            s = s + &quot;&lt;br/&gt;&quot;;
        }
        return s;
    }
    function trace( e ){
        document.getElementById(&quot;tracer&quot;).innerHTML = &quot;&lt;b&gt;&quot;+e.type+&quot;&lt;/b&gt;&lt;hr/&gt;&quot;+toStr(e);
    }

    imageViewer.prototype = {
        handleEvent : function(e){
            switch(e.type){
                case &quot;touchstart&quot;:
                    e.preventDefault();
                    trace(e);
                break;
                case &quot;touchmove&quot;:
                    trace(e);
                break;
                case &quot;touchend&quot;:
                    trace(e);
                break;
            }
        }
    }

    new imageViewer(document.getElementById('toucheventsample'));
})();

&lt;/script&gt;
</description></item><item><title>怎样下载Chrome插件和离线安装CRX文件</title><link>https://mikecyc.github.io/articles/how-to-download-chrome-plugin-and-setup-offline/</link><pubDate>Thu, 08 Mar 2012 13:52:05 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/how-to-download-chrome-plugin-and-setup-offline/</guid><author></author><description>&lt;p&gt;自从chrome网上应用店出来后，Chrome插件就无法下载插件，必须在线安装，安装后又自动把CRX文件删除，而且是那么的迅速…&lt;/p&gt;
&lt;p&gt;以下是下载离线插件包的方法：&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;第一步：&lt;/h2&gt;
&lt;p&gt;每个Google Chrome扩展都有一个固定的ID，例如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面是一个Chrome扩展的完整URL，&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;https://chrome.google.com/webstore/detail/adblock/&lt;/code&gt;之后的一串字符就是扩展的ID了。&lt;/p&gt;
&lt;p&gt;即：&lt;code&gt;gighmmpiobklfepjocnamgkkbiglidom&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把这个扩展的ID复制下来。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;h2 id=&quot;-&quot;&gt;第二步：&lt;/h2&gt;
&lt;p&gt;用扩展ID替换下面URL中的“&lt;strong&gt;~~~~&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://clients2.google.com/service/update2/crx?response=redirect&amp;amp;x=id%3D~~~~%26uc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将替换后的URL粘贴到IE或火狐中，注意&lt;strong&gt;不要粘到Chrome里&lt;/strong&gt;，那样你还是无法获得CRX扩展文件包。&lt;/p&gt;
&lt;p&gt;接下来下载保存即可。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;在线链接转换小工具&lt;/h2&gt;
&lt;p&gt;将Google Chrome扩展的完整URL或者ID粘贴在这里，将得到下载Chrome扩展的完整URL，然后复制生成的URL到IE或者火狐中下载。
如果你正在使用IE或者火狐，直接点击生成的&lt;strong&gt;链接&lt;/strong&gt;下载。&lt;/p&gt;
&lt;p&gt;&lt;div style=&quot;border:1px solid #DDD;background:#EEE;padding:10px;border-radius:5px;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;source&quot; style=&quot;width:95%&quot;/&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;&lt;p&gt;&lt;textarea id=&quot;soutput&quot; style=&quot;width:95%&quot;&gt;&lt;/textarea&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;&lt;p style=&quot;height:3.2em;&quot;&gt;&lt;a id=&quot;slink&quot; target=&quot;download&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;script&gt;
window.onload = function(){
    var source = $('#source').bind('change paste', function(){
        setTimeout(function(){
            var pt = /[a-z]{30,}/.exec(source.val());
            if(pt){
                var url = 'https://clients2.google.com/service/update2/crx?response=redirect&amp;x=id%3D'+ pt[0]+ '%26uc';
                $('#soutput').val(url).focus().select();
                $('#slink').attr('href', url).html(url);
            }else{
                $('#soutput').val('源链接格式不对');
                $('#slink').attr('href', '').html('');
            }
        }, 0);
    });
}
&lt;/script&gt;

&lt;h2 id=&quot;-&quot;&gt;安装方法：&lt;/h2&gt;
&lt;p&gt;打开chrome，把CRX文件拖到chrome中，下方会有提示，继续即可，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/how-to-download-chrome-plugin-and-setup-offline/setup-chrome-plugin.jpg&quot; alt=&quot;离线安装Chrome插件&quot;&gt;&lt;/p&gt;
</description></item><item><title>为什么信耶稣？[甘力克]</title><link>https://mikecyc.github.io/articles/why-jesus/</link><pubDate>Thu, 08 Mar 2012 13:52:05 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/why-jesus/</guid><author></author><description>&lt;h2 id=&quot;-&quot;&gt;怎么回事？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;01.gif&quot; width=&quot;168&quot; height=&quot;172&quot; align=&quot;right&quot; hsapce=&quot;15&quot;/&gt;&lt;/p&gt;
&lt;p&gt;人生在世，最叫人振奋的事情，莫如：成功的人际关系——父子、夫妇、爱侣、朋友等。&lt;/p&gt;
&lt;p&gt;有人以为基督教信仰不外乎一大堆教义、戒律、规条，但其实基督教信仰的精髓在乎——在乎一个人，而不仅仅是一套哲学理论。&lt;strong&gt;基督教信仰所着重的关系，是人世间最重要的关系——人与造物主的关系。&lt;/strong&gt;耶稣说首要的诫命是全心爱神，其次是爱人如己——两条诫命都涉及关系。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;所为何事？&lt;/h2&gt;
&lt;p&gt;你我受造于世，就是为了与神建立关系。除非我们与神复合，否则总会觉得生命欠缺一点什么。世人常常感到空虚无助，就是这个缘故。有一个摇滚乐手这样形容他内心的感受：“我心里，空虚难受。”&lt;/p&gt;
&lt;p&gt;有一个家庭主妇写信给我，说她“心中有一大片空白”；另一个女孩说她“灵魂穿了一个大洞。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;02.jpg&quot; align=&quot;left&quot; width=&quot;197&quot; height=&quot;206&quot;&gt;&lt;/p&gt;
&lt;p&gt;世人用各种方法来填补心中的空洞。有人希望用钱填补——可惜钱财不能满足人心。已故希腊船王奥纳西斯(Aristotle S.Onassis)是世界首富之一，临终前说过这样的话：“人即使拥有万贯家财，也不能满足人心的需求。”&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;p&gt;又有人吸毒、酗酒、滥交。有一个女孩告诉我说：“这些事可以带来一时的快感，可是过后只会觉得更空虚。”又有人朝夕工作，醉心音乐、拼命运动、竞逐名声——这些事本身并无不妥，但不能满足人内心的饥渴。&lt;/p&gt;
&lt;p&gt;人就算得着乐人世界最亲密的关系，也不足以填满“心里头的空虚”！&lt;/p&gt;
&lt;p&gt;人受造原是为了与神在爱中合一，人若持续与神不和好，心里总不会感到满足。&lt;/p&gt;
&lt;p&gt;按照新约圣经的说法，人心感到空虚，因人背弃了神。&lt;/p&gt;
&lt;p&gt;耶稣说：&lt;code&gt;“我就是生命的粮。”(约 6:35)&lt;/code&gt; 是的，只有耶稣可以使我们的心灵得满足，因为惟有耶稣可以帮助我们与神重修旧好。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;一、“一生为何？”&lt;/h3&gt;
&lt;p&gt;我们迟早会问自己这样的一个问题：“我在有生之年，改作些什么？”“生命意义何在？”“人生在世，有什么目标吗？”&lt;/p&gt;
&lt;p&gt;存在主义学家卡穆(Albert Camus)说过：“人总不能漫无目的的生存下去。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;04.gif&quot; align=&quot;right&quot; width=&quot;138&quot; height=&quot;196&quot;&gt;&lt;/p&gt;
&lt;p&gt;除非与神建立了关系，否则不能找到人生的真正目标意义。人离开了神，万事不过一场烟云，转眼间已成了空！我们与造物主建立了关系，就能够明白人生的真正目标与意义。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二、“死后何往？”&lt;/h3&gt;
&lt;p&gt;我成为基督徒前，总会避谈“死”这个题目。我觉得自己离死很远！我不知道人死后是什么世界，也不想多作猜测——但其实我在逃避现实，因为人人难逃一死——偏偏神&lt;code&gt;“把永生安置在世人心里！”(传 3:11)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;世人都不想死，都想逃避死亡——可是，&lt;strong&gt;惟有藉着耶稣才可以得着永生&lt;/strong&gt;——我们藉着耶稣与神建立了关系，不仅始于今生，更可以持续到永远。死亡不能断绝我们与神的关系。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三、“罪疚难当？”&lt;/h3&gt;
&lt;p&gt;我们如果自己诚实，就一定会承认自己常做错事——偶尔更会做出一些叫自己深以为耻的丑事！我们实在是自私自利的人，生命更遍布污点！&lt;/p&gt;
&lt;p&gt;耶稣说：&lt;code&gt;“从人里面出来的，那才能‘污秽’人。因为从人里面，就是从人心里，发出恶念：苟合、偷盗、凶杀、奸淫、贪婪、邪恶、诡诈、淫荡、嫉妒、亵渎、骄傲、狂妄……这一切的恶，都是从里面出来，且能污秽人。”(马可福音7：20－23)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;人心灵最大需要，是“罪得赦免”。患癌症的人不论他想不想见医生，都需要接受诊治。同样的，犯罪的人，不论他是否认同自己有罪，都需要得着宽恕。察觉到自己有需要的人，当然比欺骗自己说没有问题的人好多了。&lt;/p&gt;
&lt;p&gt;耶稣在十字架上为我们代罪受死，我们才有机会得着宽恕，与神修复关系，我们心灵的最大需要，由此得着满足。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;耶稣与我何干？&lt;/h2&gt;
&lt;p&gt;为何要接受基督教信仰？再明显不过的答案是：&lt;strong&gt;因为基督教信仰是真理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果基督教信的不是真理，基督徒就在浪费自己和别人的时间！&lt;/p&gt;
&lt;p&gt;如果基督教信的是真理，那就对人人都极为重要了。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;我们怎样知道基督教信仰的真伪？&lt;/h2&gt;
&lt;p&gt;我们可以验证基督教信仰的真伪，因为基督教信仰是建基于历史事实上——关乎耶稣这个历史人物的出生、工作、受死、复活——这些全都有可供验证真伪的历史事实。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;06.gif&quot; width=&quot;371&quot; height=&quot;111&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;耶稣是谁？&lt;/h2&gt;
&lt;p&gt;耶稣是历史上最卓越不凡的人物，是西方文化的轴心——我们今天采用的历法，就是以耶稣的出生为划分：耶稣出生之前的年份称为：“主前”(Before Christ，简称BC)；耶稣出生之后的年份称为(Anno Domini，简称AD)。&lt;/p&gt;
&lt;p&gt;耶稣是神的儿子。有人以为耶稣只不过是一个“优秀的宗教导师”——这看法显然不符合历史事实。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;一、耶稣的宣称&lt;/h3&gt;
&lt;p&gt;耶稣说过祂是神的儿子，与神同等：耶稣宣称自己有赦罪的权柄，又说祂有一天要审判世界——世人终极命运如何，全在乎他们在世之时，如何看待耶稣。&lt;/p&gt;
&lt;p&gt;已故剑桥大学教授、名作家鲁益师(C.S.Lewies)说得好：“如果耶稣只是凡人，却说出‘新约圣经所记的’那些话，他就绝对不可能是万世师表！他要么是疯到一个程度说自己是个皮蛋，要么是地狱的恶魔——我们必须作出选择：耶稣若非神子，就必然是狂人(甚至比狂人更恐怖的人！)……不要再自以为是地胡说耶稣是什么“万世师表”了——他的言行催迫我们选定路向——这当中不存在着模棱两可的犹疑！”&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二、耶稣的品格&lt;/h3&gt;
&lt;p&gt;很多不会自称为基督徒的人，却会同意耶稣的一生是“毫不利己，全心为人”的完美榜样。大文豪陀妥也夫斯基(F.M.Dostoevsky)说：“我相信不会有人比耶稣更可爱、更有深度、更仁厚、更纯洁。虽不情愿，但不可不承认：‘从来没有人能与耶稣相比，将来也不会有人能比得上祂。’”&lt;/p&gt;
&lt;p&gt;耶稣的教导，是举世公认最纯全、最深刻的教训——比古今中外任何哲人学士所说的都好。&lt;/p&gt;
&lt;p&gt;鲁益师说：“事实摆在眼前，耶稣显然不是疯子或恶魔，因此，不论我觉得如何离奇、惊诧、难以置信，仍不得不承认一件事实：耶稣的的确确是神。神曾经道成肉身，来到这被仇敌占据的世界。”&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三、耶稣胜过死亡&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;08.gif&quot; align=&quot;left&quot; hsapce=&quot;15&quot; width=&quot;221&quot; height=&quot;195&quot;&gt;&lt;/p&gt;
&lt;p&gt;耶稣从死里复活的证据实在无懈可击。当耶稣的门徒跑进了耶稣的坟墓里，他们发现耶稣的尸身不见了，只剩下裹尸布叠在一旁。&lt;/p&gt;
&lt;p&gt;其后六个礼拜，有超过500人亲眼看见耶稣。本来已灰心丧气的门徒们，生命就此忽然改换一新，基督教会也就此诞生，并且增长迅猛！&lt;/p&gt;
&lt;p&gt;前英国首席大法令勋爵(Lord Darling)说过：“支持耶稣从死里复活的证据确凿——不论正面证据、反面证据、事实证据、环境证据，都不存在任何破绽！任何头脑清醒的陪审团，必然会作出一致的判决：耶稣复活的历史事实千真万确。”&lt;/p&gt;
&lt;p&gt;对这些事实唯一合理的解释是，耶稣曾经从死里复活，所以证明他真是神的儿子。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;耶稣为什么降世为人？&lt;/h2&gt;
&lt;p&gt;耶稣是唯一一个&lt;code&gt;自己决定要来到世间的人，也是极少数甘愿受死的人。耶稣曾经说过，祂降世的唯一目的就是为我们死：“人子来……要舍命，作多人的赎价。”(可 10:45)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;十字架是人类历史上数一数二的残酷刑具。历史学家西塞罗(Cicero)形容十字架的刑罚是“酷刑中最残忍可怖之酷刑。”&lt;/p&gt;
&lt;p&gt;耶稣被钉十字架前，要先被绑在一条柱子上受鞭打；那鞭子不是普通的皮鞭，而是4、5条镶有尖刺铅粒的皮条带合成的鞭子。主后三世界教会史学家西比乌斯(Eusebius)这样描述罗马人的鞭刑：“犯人皮开肉绽，肌腱与内脏尽现！”&lt;/p&gt;
&lt;p&gt;耶稣受完鞭刑，还要被迫把六尺长的十字架背到受刑的山上去(耶稣途中不支倒地)。耶稣到了钉十字架地地方，兵丁用六寸长的大钉子，猛力去钉耶稣的手腕和脚，钉牢了，就把十字架竖起来。耶稣悬挂在十字架上有六个钟头之久，祂的生命在难以言喻的剧痛中，一点点的流逝。&lt;/p&gt;
&lt;p&gt;可是耶稣受的最大痛苦并不关于肉体，甚至不关于精神，却关乎灵性——耶稣背负我们的罪，不得不与至圣的父神上帝暂时隔绝。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;耶稣为什么死？&lt;/h2&gt;
&lt;p&gt;耶稣说他为我们死——“为”是“替代”的意思。耶稣替代我们死，因为祂爱我们，不愿意我们因自己所犯的罪受刑罚。耶稣甘愿被钉十字架，无异于公开宣告：“我要以自己来承担众人的罪债。”&lt;/p&gt;
&lt;p&gt;耶稣为你死、为我死——就算你或我是世上唯一的人，耶稣也会为你死、为我死！&lt;/p&gt;
&lt;p&gt;使徒保罗说：&lt;code&gt;“神儿子……爱我、为我舍己。”(加 2:20)&lt;/code&gt;　是的，耶稣爱我们，为我们付上性命做赎价。&lt;/p&gt;
&lt;p&gt;“赎身”的原意出自奴隶市场：一个人付上价银，买下一个奴隶，然后让奴隶自由离去，这就是“赎身”。替人赎身的人必须付出赎价——耶稣以十字架上倾流的血为我们付了赎价，使我们得自由。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;10.gif&quot; align=&quot;right&quot; width=&quot;189&quot; height=&quot;130&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;怎样得释放？&lt;/h2&gt;
&lt;h3 id=&quot;-&quot;&gt;一、 摆脱罪疚&lt;/h3&gt;
&lt;p&gt;无论我们觉得内疚与否，总也不能抹杀一个事实：我们经常会在思想、言语、行为上触犯神的律法。人触犯地上的律法，尚且要面对刑罚，何况触犯神的律法？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;“罪的工价乃是死。”(罗 6:23)&lt;/code&gt; 人触犯神的律法，所受的刑罚是死——与神永远隔绝。世人都犯了罪，都要接受永死的刑罚，但耶稣在十字架上替我们受了死刑，我们因此可以得着完全赦免，连罪疚也可以得除净。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二、 摆脱犯罪的习惯&lt;/h3&gt;
&lt;p&gt;犯罪会成瘾的。耶稣说：&lt;code&gt;“所有犯罪的，都是罪的奴仆。”(约 8:34)&lt;/code&gt; 耶稣为我们死，叫我们摆脱罪的管辖。耶稣在十字架上打垮了罪的权势，因此耶稣可宣告：&lt;code&gt;“天父的儿子若要你们得自由，你们就真自由了。”(约 8:36)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三、 摆脱恐惧&lt;/h3&gt;
&lt;p&gt;耶稣来到世间，&lt;code&gt;“特要借着死，败坏那掌死权的，就是魔鬼，并要释放那些一生因怕死而成奴仆的人。”(希伯来书2：14－15)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们实在不用再惧怕死亡！——因著耶稣得救的人，不用再惧怕死亡，因为死亡不再是基督徒的终点，却是通往天堂的门道——在天堂不再有任何奴役，甚至不会见到罪的踪影！&lt;/p&gt;
&lt;p&gt;因为耶稣的救赎，我们一旦摆脱死亡的恐惧，也就摆脱其它一切的恐惧了。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;获释放，得到什么自由？&lt;/h2&gt;
&lt;p&gt;耶稣的肉身已不在世上，但耶稣没有撇下我们不顾，反而赐下圣灵住在我们心中。我们若有耶稣的灵居住在心中，就可得著前所未有的自由。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;13.jpg&quot; align=&quot;right&quot; hsapce=&quot;15&quot; width=&quot;191&quot; height=&quot;171&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;一、 得到认识神的自由&lt;/h3&gt;
&lt;p&gt;我们犯的错成为神和我们之间的障碍。&lt;code&gt;以赛亚书59：2说：“你们的罪孽使你们与神隔绝。”&lt;/code&gt; 藉着耶稣在十字架上的死，拆除了人神之间的阻隔，使我们得以与创造主建立关系，成为神的儿女！圣灵会在我们心中确认这种关系，并帮助我们亲近神，认识神。&lt;/p&gt;
&lt;p&gt;圣灵又会帮助我们祷告，开启我们的心眼，让我们明白神的话语(圣经)。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二、 得到爱神爱人的自由&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;“我们爱，因为神先爱我们”(约一 4:19)&lt;/code&gt; 我们仰望主的十字架，就能感受神的爱；当圣灵进住我们的心中，我们感受到神的爱，就会生出爱神、爱人的心。耶稣释放了我们，叫我们的生命焕发爱的光辉——我们活着是为了爱耶稣、服事耶稣，也是为了爱人、服事人，而不仅仅是为了自己的益处。　&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三、 得到洗心革面的自由&lt;/h3&gt;
&lt;p&gt;俗语有云：“江山易改，本性难移。”然而耶稣的福音是：靠着圣灵，人的品性可以焕然一新。其实人人心底都有一个向善的渴求工：但愿自己可以脱胎换骨！&lt;/p&gt;
&lt;p&gt;使徒保罗告诉我们：&lt;code&gt;“圣灵所结的果子是仁爱、喜乐、和平、忍耐、恩慈、良善、信实、温柔、节制。”(加 5:22)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当圣灵进到我们心里，从圣灵而来的美好特质，也会逐渐显现在我们的生命里。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;不信的借口？&lt;/h2&gt;
&lt;p&gt;神愿意在基督耶稣里宽恕我们、释放我们、赐我们圣灵居住心中——这全都是神赐人的礼物。我们面对礼物，可以选择要或不要：我们可以双手接过礼物包，兴高采烈地打开，再慢慢体味送礼人的深情厚意；我们也可以连连摆手说：“不了，心领了。”&lt;/p&gt;
&lt;p&gt;可惜的是，很多人面对神的礼物都选择了“不要”，他们有千百样的借口！ 以下是几个例子：&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;一、“我不需要神”&lt;/h3&gt;
&lt;p&gt;这话背后的真正意思是：“我现在不是很快乐吗？我要神来干嘛？”说这话的人忽略了一事：人心灵最大的需要，不是得着“快乐”，而是得着“宽恕” ——唯有最狂傲的才敢夸口说自己不需要得着宽恕。&lt;/p&gt;
&lt;p&gt;我们都需要得着宽恕——尤其是需要得着神的宽恕，否则后果不堪设想——因为神不但是慈爱的父亲，也是公义的终极审判官。&lt;/p&gt;
&lt;p&gt;我们需要领受耶稣在十字架上为我们成就的救恩，否则终有一天得独自清还个人的所有罪债。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;15.jpg&quot; align=&quot;right&quot; hsapce=&quot;15&quot; width=&quot;204&quot; height=&quot;248&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二、“我要放弃的太多了”&lt;/h3&gt;
&lt;p&gt;有时，神会使我们明白，如果我们想与神建立深交，我们生活中的某些恶习，必需要摒除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可不要忘了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;☆ 神爱我们，只会要求我们放弃对我们有损无益的事。如果我们看见小儿子拿尖刀玩，我们会马上制止他——不是要扫他的兴，而是不想他受伤害。&lt;/p&gt;
&lt;p&gt;☆ 我们所放弃的，远远比不上我们所得着的——不做基督徒要付出的代价，远远高过做基督徒付出的代价。&lt;/p&gt;
&lt;p&gt;☆ 我们所放弃的，远远比不上神子耶稣所放弃的：耶稣已在十字架上为你我的罪而流血舍命！&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三、“一定有阴谋”&lt;/h3&gt;
&lt;p&gt;人有时难以相信世上真有白白得来的礼物，他们觉得基督徒所说的救恩得来的太容易了，因此当中必有阴谋！这些人忽略了的是：人虽然白白的得着救恩，耶稣却为这救恩付出了高昂的代价，就是他的性命；我们得来容易，耶稣却付出重大！&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;四、“我不够好”&lt;/h3&gt;
&lt;p&gt;我们每个人都不够好！无论我们怎样努力做好，在神眼中也不完美，所以耶稣才要降世救人！藉着耶稣成就的救恩，我们才有胆量以真面目去到神面前，而神也会照着我们的本相接纳我们——不论我们是否犯下弥天大错，或者多么无药可救。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;五、“我担心不能坚持下去”&lt;/h3&gt;
&lt;p&gt;如果我们单凭自己努力的话——我们的确没有能耐去做个好基督徒。好消息是：神的灵会进到我们心中，使我们刚强起来，又不断赐能力去跟随主。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;六、“以后再算吧”&lt;/h3&gt;
&lt;p&gt;这个可能是最常见的籍口。很多人说：“我知道基督教信的是真理，但对我还不是适当时候……”他们就此打消了念头！这实在是太可惜了，因为人越是耽误，越是不想做出决定，也就越错失了神的祝福——人也是实在不能确定自己有否“下一次”机会。对我而言，我生平一大憾事，就是自己为什么不早一点领受神的祝福？&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;我们该采取什么行动？&lt;/h2&gt;
&lt;p&gt;新约圣经清楚告诉我们，我们若要领受神的礼物，就必须有所行动——我们必须表白对神的信心。&lt;/p&gt;
&lt;p&gt;使徒约翰说：&lt;code&gt;“神爱世人，甚至将他的独生子赐给他们，叫一切信他的，不至灭亡，反得永生。”(约 3:16)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;“信”的人必须向神投入信心，信耶稣是建基于我们对耶稣的认识之后所做出的行动——信耶稣不是盲从附和，而是全心信任耶稣，把生命交托耶稣，就是婚礼中的男女彼此承诺说：&lt;strong&gt;“我愿意。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人向神踏出第一步，方式各有不同。如果你现在就想向神踏出这一步，请你接受我提供给你的一个简单方法，这方法可以用三句话概括：&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;一、“对不起”&lt;/h3&gt;
&lt;p&gt;你必须求神宽恕你过去所做的一切错事，并且立志改过自新——圣经称这决定为“悔改”。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二、“谢谢”&lt;/h3&gt;
&lt;p&gt;我们相信耶稣为我们钉死在十字架上。你要感谢耶稣为你死，也要感谢他白白宽恕你、释放你、赐圣灵给你。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三、“邀请”&lt;/h3&gt;
&lt;p&gt;神不会硬闯我们的生命！你必须乐意接受神的礼物，主动邀请他的圣灵进到你心中居住。&lt;/p&gt;
&lt;p&gt;如果你想与神建立关系，又愿意作出上述表示，就可以用下面的祷文向神祷告，向神踏出第一步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主耶稣基督：

我过去做了很多错事，现在真的后悔了。(你可以用几分钟时间想想自己犯了什么错，然后求神赦免。)

主耶稣啊，求您赦免我，我要改过自新，不再故意触犯您的诫命。感谢您为我的罪死在十字架上，让我得着赦免，并从罪中释放！

感谢您愿意随时赦免我，又赐圣灵进入我心。我要领受您的赦免，也要领受您的圣灵！主耶稣啊，求您借着圣灵常常与我同在。

主耶稣啊，我感谢您倾听我的祷告。阿门！(诚心所愿)。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;-&quot;&gt;然后又如何？&lt;/h2&gt;
&lt;h3 id=&quot;-&quot;&gt;一、 把你信耶稣的事告诉别人&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;19.gif&quot; align=&quot;right&quot; hsapce=&quot;15&quot; width=&quot;160&quot; height=&quot;236&quot;&gt;&lt;/p&gt;
&lt;p&gt;你一定要把你信耶稣的事告诉别人，好表明你做的决定。有时候我们向人表白信仰后，所信的才变得实在。但有一事我要提醒你：开始的时候，你最好先把你信耶稣的消息，告诉那些希望你信耶稣的人！&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二、 读圣经&lt;/h3&gt;
&lt;p&gt;我们信耶稣，把生命交托耶稣，就成了神的儿女(约 1:12)。神是我们天上的父亲，祂和地上的父亲一样，渴望与儿女亲亲密密。我们聆听父神的话(主要是藉着圣经)，向父神倾吐心声(籍着祷告)，与父神感情就会日益加深。圣经是神的话语，若你刚开始读圣经，不用心急，每天读几节约翰福音就好了，要紧的是求神在你读圣经的时候向你说话。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三、 天天与神倾谈心事（祷告）&lt;/h3&gt;
&lt;p&gt;有一个祷告模式很能够帮助我们祷告，简称为“ACTS”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A —— Adoration(倾慕)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为神的美善、神的作为赞美神。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C —— Confession(认罪)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求神赦免我们的过错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T —— Thanksgiving(感恩)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为健康、家人、朋友等等献上感恩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S —— Supplication(祈求)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为自己、朋友、其它人的需要祈求。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;四、 加入一家有生气的教会&lt;/h3&gt;
&lt;p&gt;我们必须成为教会的一员。教会是一群基督徒聚集敬拜、听候神的说话，与弟兄姊妹相知相交、鼓励互勉的地方——因此不难想像是个活泼及吸引人的地方！&lt;/p&gt;
&lt;p&gt;我在1974年2月16日信耶稣，向神做了一个短短的祷告(就象上面“邀请”的祷文)，就此改变了一生。那是我一生中最明智、最重大的决定！如果你信耶稣，我肯定这决定也会成为你一生最明智、最重大的决定。&lt;/p&gt;
</description></item><item><title>Markdown syntax</title><link>https://mikecyc.github.io/articles/markdown-syntax/</link><pubDate>Thu, 02 Feb 2012 08:00:00 +0800</pubDate><guid isPermaLink="true">https://mikecyc.github.io/articles/markdown-syntax/</guid><author></author><description>&lt;p&gt;Full markdown syntax taken from John Gruber’s &lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Daring Fireball&lt;/a&gt;.
Did you know that 9 out of 10 bloggers prefer to write in markdown?&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;markdown-syntax&quot;&gt;Markdown: Syntax&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#overview&quot;&gt;Overview&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#philosophy&quot;&gt;Philosophy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#html&quot;&gt;Inline HTML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#autoescape&quot;&gt;Automatic Escaping for Special Characters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#block&quot;&gt;Block Elements&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#p&quot;&gt;Paragraphs and Line Breaks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#header&quot;&gt;Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#blockquote&quot;&gt;Blockquotes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#list&quot;&gt;Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#precode&quot;&gt;Code Blocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#hr&quot;&gt;Horizontal Rules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#span&quot;&gt;Span Elements&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#link&quot;&gt;Links&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#em&quot;&gt;Emphasis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#img&quot;&gt;Images&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#misc&quot;&gt;Miscellaneous&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#backslash&quot;&gt;Backslash Escapes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#autolink&quot;&gt;Automatic Links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This document is itself written using Markdown; you
can &lt;a href=&quot;https://mikecyc.github.io/projects/markdown/syntax.text&quot;&gt;see the source for it by adding ‘.text’ to the URL&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&quot;philosophy&quot;&gt;Philosophy&lt;/h3&gt;

&lt;p&gt;Markdown is intended to be as easy-to-read and easy-to-write as is feasible.&lt;/p&gt;
&lt;p&gt;Readability, however, is emphasized above all else. A Markdown-formatted
document should be publishable as-is, as plain text, without looking
like it’s been marked up with tags or formatting instructions. While
Markdown’s syntax has been influenced by several existing text-to-HTML
filters – including &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt;, &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt;, &lt;a href=&quot;http://textism.com/tools/textile/&quot;&gt;Textile&lt;/a&gt;, &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;reStructuredText&lt;/a&gt;,
&lt;a href=&quot;http://www.triptico.com/software/grutatxt.html&quot;&gt;Grutatext&lt;/a&gt;, and &lt;a href=&quot;http://ettext.taint.org/doc/&quot;&gt;EtText&lt;/a&gt; – the single biggest source of
inspiration for Markdown’s syntax is the format of plain text email.&lt;/p&gt;
&lt;p&gt;To this end, Markdown’s syntax is comprised entirely of punctuation
characters, which punctuation characters have been carefully chosen so
as to look like what they mean. E.g., asterisks around a word actually
look like *emphasis*. Markdown lists look like, well, lists. Even
blockquotes look like quoted passages of text, assuming you’ve ever
used email.&lt;/p&gt;
&lt;h3 id=&quot;html&quot;&gt;Inline HTML&lt;/h3&gt;

&lt;p&gt;Markdown’s syntax is intended for one purpose: to be used as a
format for &lt;em&gt;writing&lt;/em&gt; for the web.&lt;/p&gt;
&lt;p&gt;Markdown is not a replacement for HTML, or even close to it. Its
syntax is very small, corresponding only to a very small subset of
HTML tags. The idea is &lt;em&gt;not&lt;/em&gt; to create a syntax that makes it easier
to insert HTML tags. In my opinion, HTML tags are already easy to
insert. The idea for Markdown is to make it easy to read, write, and
edit prose. HTML is a &lt;em&gt;publishing&lt;/em&gt; format; Markdown is a &lt;em&gt;writing&lt;/em&gt;
format. Thus, Markdown’s formatting syntax only addresses issues that
can be conveyed in plain text.&lt;/p&gt;
&lt;p&gt;For any markup that is not covered by Markdown’s syntax, you simply
use HTML itself. There’s no need to preface it or delimit it to
indicate that you’re switching from Markdown to HTML; you just use
the tags.&lt;/p&gt;
&lt;p&gt;The only restrictions are that block-level HTML elements – e.g. &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;,
&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;, etc. – must be separated from surrounding
content by blank lines, and the start and end tags of the block should
not be indented with tabs or spaces. Markdown is smart enough not
to add extra (unwanted) &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags around HTML block-level tags.&lt;/p&gt;
&lt;p&gt;For example, to add an HTML table to a Markdown article:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is a regular paragraph.

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

This is another regular paragraph.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that Markdown formatting syntax is not processed within block-level
HTML tags. E.g., you can’t use Markdown-style &lt;code&gt;*emphasis*&lt;/code&gt; inside an
HTML block.&lt;/p&gt;
&lt;p&gt;Span-level HTML tags – e.g. &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; – can be
used anywhere in a Markdown paragraph, list item, or header. If you
want, you can even use HTML tags instead of Markdown formatting; e.g. if
you’d prefer to use HTML &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tags instead of Markdown’s
link or image syntax, go right ahead.&lt;/p&gt;
&lt;p&gt;Unlike block-level HTML tags, Markdown syntax &lt;em&gt;is&lt;/em&gt; processed within
span-level tags.&lt;/p&gt;
&lt;h3 id=&quot;autoescape&quot;&gt;Automatic Escaping for Special Characters&lt;/h3&gt;

&lt;p&gt;In HTML, there are two characters that demand special treatment: &lt;code&gt;&amp;lt;&lt;/code&gt;
and &lt;code&gt;&amp;amp;&lt;/code&gt;. Left angle brackets are used to start tags; ampersands are
used to denote HTML entities. If you want to use them as literal
characters, you must escape them as entities, e.g. &lt;code&gt;&amp;amp;lt;&lt;/code&gt;, and
&lt;code&gt;&amp;amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ampersands in particular are bedeviling for web writers. If you want to
write about ‘AT&amp;amp;T’, you need to write ‘&lt;code&gt;AT&amp;amp;amp;T&lt;/code&gt;‘. You even need to
escape ampersands within URLs. Thus, if you want to link to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;you need to encode the URL as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;in your anchor tag &lt;code&gt;href&lt;/code&gt; attribute. Needless to say, this is easy to
forget, and is probably the single most common source of HTML validation
errors in otherwise well-marked-up web sites.&lt;/p&gt;
&lt;p&gt;Markdown allows you to use these characters naturally, taking care of
all the necessary escaping for you. If you use an ampersand as part of
an HTML entity, it remains unchanged; otherwise it will be translated
into &lt;code&gt;&amp;amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, if you want to include a copyright symbol in your article, you can write:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;amp;copy;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and Markdown will leave it alone. But if you write:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AT&amp;amp;T
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown will translate it to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AT&amp;amp;amp;T
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Similarly, because Markdown supports &lt;a href=&quot;#html&quot;&gt;inline HTML&lt;/a&gt;, if you use
angle brackets as delimiters for HTML tags, Markdown will treat them as
such. But if you write:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 &amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown will translate it to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4 &amp;amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, inside Markdown code spans and blocks, angle brackets and
ampersands are &lt;em&gt;always&lt;/em&gt; encoded automatically. This makes it easy to use
Markdown to write about HTML code. (As opposed to raw HTML, which is a
terrible format for writing about HTML syntax, because every single &lt;code&gt;&amp;lt;&lt;/code&gt;
and &lt;code&gt;&amp;amp;&lt;/code&gt; in your example code needs to be escaped.)&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;block&quot;&gt;Block Elements&lt;/h2&gt;


&lt;h3 id=&quot;p&quot;&gt;Paragraphs and Line Breaks&lt;/h3&gt;

&lt;p&gt;A paragraph is simply one or more consecutive lines of text, separated
by one or more blank lines. (A blank line is any line that looks like a
blank line – a line containing nothing but spaces or tabs is considered
blank.) Normal paragraphs should not be indented with spaces or tabs.&lt;/p&gt;
&lt;p&gt;The implication of the “one or more consecutive lines of text” rule is
that Markdown supports “hard-wrapped” text paragraphs. This differs
significantly from most other text-to-HTML formatters (including Movable
Type’s “Convert Line Breaks” option) which translate every line break
character in a paragraph into a &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; tag.&lt;/p&gt;
&lt;p&gt;When you &lt;em&gt;do&lt;/em&gt; want to insert a &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; break tag using Markdown, you
end a line with two or more spaces, then type return.&lt;/p&gt;
&lt;p&gt;Yes, this takes a tad more effort to create a &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;, but a simplistic
“every line break is a &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;“ rule wouldn’t work for Markdown.
Markdown’s email-style &lt;a href=&quot;#blockquote&quot;&gt;blockquoting&lt;/a&gt; and multi-paragraph &lt;a href=&quot;#list&quot;&gt;list items&lt;/a&gt;
work best – and look better – when you format them with hard breaks.&lt;/p&gt;
&lt;h3 id=&quot;header&quot;&gt;Headers&lt;/h3&gt;

&lt;p&gt;Markdown supports two styles of headers, &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt; and &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Setext-style headers are “underlined” using equal signs (for first-level
headers) and dashes (for second-level headers). For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is an H1
=============

This is an H2
-------------
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Any number of underlining &lt;code&gt;=&lt;/code&gt;‘s or &lt;code&gt;-&lt;/code&gt;‘s will work.&lt;/p&gt;
&lt;p&gt;Atx-style headers use 1-6 hash characters at the start of the line,
corresponding to header levels 1-6. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This is an H1

## This is an H2

###### This is an H6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Optionally, you may “close” atx-style headers. This is purely
cosmetic – you can use this if you think it looks better. The
closing hashes don’t even need to match the number of hashes
used to open the header. (The number of opening hashes
determines the header level.) :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This is an H1 #

## This is an H2 ##

### This is an H3 ######
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;blockquote&quot;&gt;Blockquotes&lt;/h3&gt;

&lt;p&gt;Markdown uses email-style &lt;code&gt;&amp;gt;&lt;/code&gt; characters for blockquoting. If you’re
familiar with quoting passages of text in an email message, then you
know how to create a blockquote in Markdown. It looks best if you hard
wrap the text and put a &lt;code&gt;&amp;gt;&lt;/code&gt; before every line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt;
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown allows you to be lazy and only put the &lt;code&gt;&amp;gt;&lt;/code&gt; before the first
line of a hard-wrapped paragraph:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by
adding additional levels of &lt;code&gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; This is the first level of quoting.
&amp;gt;
&amp;gt; &amp;gt; This is nested blockquote.
&amp;gt;
&amp;gt; Back to the first level.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Blockquotes can contain other Markdown elements, including headers, lists,
and code blocks:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;this-is-a-header-&quot;&gt;This is a header.&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;This is the first list item.&lt;/li&gt;
&lt;li&gt;This is the second list item.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here’s some example code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return shell_exec(&amp;quot;echo $input | $markdown_script&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Any decent text editor should make email-style quoting easy. For
example, with BBEdit, you can make a selection and choose Increase
Quote Level from the Text menu.&lt;/p&gt;
&lt;h3 id=&quot;list&quot;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Markdown supports ordered (numbered) and unordered (bulleted) lists.&lt;/p&gt;
&lt;p&gt;Unordered lists use asterisks, pluses, and hyphens – interchangably
– as list markers:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Red
*   Green
*   Blue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is equivalent to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+   Red
+   Green
+   Blue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-   Red
-   Green
-   Blue
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ordered lists use numbers followed by periods:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Bird
2.  McHale
3.  Parish
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It’s important to note that the actual numbers you use to mark the
list have no effect on the HTML output Markdown produces. The HTML
Markdown produces from the above list is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;McHale&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Parish&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you instead wrote the list in Markdown like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Bird
1.  McHale
1.  Parish
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;or even:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3. Bird
1. McHale
8. Parish
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;you’d get the exact same HTML output. The point is, if you want to,
you can use ordinal numbers in your ordered Markdown lists, so that
the numbers in your source match the numbers in your published HTML.
But if you want to be lazy, you don’t have to.&lt;/p&gt;
&lt;p&gt;If you do use lazy list numbering, however, you should still start the
list with the number 1. At some point in the future, Markdown may support
starting ordered lists at an arbitrary number.&lt;/p&gt;
&lt;p&gt;List markers typically start at the left margin, but may be indented by
up to three spaces. List markers must be followed by one or more spaces
or a tab.&lt;/p&gt;
&lt;p&gt;To make lists look nice, you can wrap items with hanging indents:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But if you want to be lazy, you don’t have to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If list items are separated by blank lines, Markdown will wrap the
items in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags in the HTML output. For example, this input:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Bird
*   Magic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;will turn into:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Magic&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   Bird

*   Magic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;will turn into:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Bird&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Magic&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;List items may consist of multiple paragraphs. Each subsequent
paragraph in a list item must be indented by either 4 spaces
or one tab:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It looks nice if you indent every line of the subsequent
paragraphs, but here again, Markdown will allow you to be
lazy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You&amp;#39;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To put a blockquote within a list item, the blockquote’s &lt;code&gt;&amp;gt;&lt;/code&gt;
delimiters need to be indented:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To put a code block within a list item, the code block needs
to be indented &lt;em&gt;twice&lt;/em&gt; – 8 spaces or two tabs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   A list item with a code block:

        &amp;lt;code goes here&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It’s worth noting that it’s possible to trigger an ordered list by
accident, by writing something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1986. What a great season.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In other words, a &lt;em&gt;number-period-space&lt;/em&gt; sequence at the beginning of a
line. To avoid this, you can backslash-escape the period:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1986\. What a great season.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;precode&quot;&gt;Code Blocks&lt;/h3&gt;

&lt;p&gt;Pre-formatted code blocks are used for writing about programming or
markup source code. Rather than forming normal paragraphs, the lines
of a code block are interpreted literally. Markdown wraps a code block
in both &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
&lt;p&gt;To produce a code block in Markdown, simply indent every line of the
block by at least 4 spaces or 1 tab. For example, given this input:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is a normal paragraph:

    This is a code block.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown will generate:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is a normal paragraph:&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;This is a code block.
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One level of indentation – 4 spaces or 1 tab – is removed from each
line of the code block. For example, this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Here is an example of AppleScript:

    tell application &amp;quot;Foo&amp;quot;
        beep
    end tell
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;will turn into:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Here is an example of AppleScript:&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;tell application &amp;quot;Foo&amp;quot;
    beep
end tell
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A code block continues until it reaches a line that is not indented
(or the end of the article).&lt;/p&gt;
&lt;p&gt;Within a code block, ampersands (&lt;code&gt;&amp;amp;&lt;/code&gt;) and angle brackets (&lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;)
are automatically converted into HTML entities. This makes it very
easy to include example HTML source code using Markdown – just paste
it and indent it, and Markdown will handle the hassle of encoding the
ampersands and angle brackets. For example, this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;
        &amp;amp;copy; 2004 Foo Corporation
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;will turn into:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;div class=&amp;quot;footer&amp;quot;&amp;amp;gt;
    &amp;amp;amp;copy; 2004 Foo Corporation
&amp;amp;lt;/div&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Regular Markdown syntax is not processed within code blocks. E.g.,
asterisks are just literal asterisks within a code block. This means
it’s also easy to use Markdown to write about Markdown’s own syntax.&lt;/p&gt;
&lt;h3 id=&quot;hr&quot;&gt;Horizontal Rules&lt;/h3&gt;

&lt;p&gt;You can produce a horizontal rule tag (&lt;code&gt;&amp;lt;hr /&amp;gt;&lt;/code&gt;) by placing three or
more hyphens, asterisks, or underscores on a line by themselves. If you
wish, you may use spaces between the hyphens or asterisks. Each of the
following lines will produce a horizontal rule:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* * *

***

*****

- - -

---------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;span&quot;&gt;Span Elements&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;Links&lt;/h3&gt;

&lt;p&gt;Markdown supports two style of links: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;reference&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In both styles, the link text is delimited by [square brackets].&lt;/p&gt;
&lt;p&gt;To create an inline link, use a set of regular parentheses immediately
after the link text’s closing square bracket. Inside the parentheses,
put the URL where you want the link to point, along with an &lt;em&gt;optional&lt;/em&gt;
title for the link, surrounded in quotes. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is [an example](http://example.com/ &amp;quot;Title&amp;quot;) inline link.

[This link](http://example.net/) has no title attribute.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Will produce:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;a href=&amp;quot;http://example.com/&amp;quot; title=&amp;quot;Title&amp;quot;&amp;gt;
an example&amp;lt;/a&amp;gt; inline link.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;http://example.net/&amp;quot;&amp;gt;This link&amp;lt;/a&amp;gt; has no
title attribute.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you’re referring to a local resource on the same server, you can
use relative paths:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;See my [About](/about/) page for details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Reference-style links use a second set of square brackets, inside
which you place a label of your choosing to identify the link:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is [an example][id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can optionally use a space to separate the sets of brackets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is [an example] [id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then, anywhere in the document, you define your link label like this,
on a line by itself:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: http://example.com/  &amp;quot;Optional Title Here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Square brackets containing the link identifier (optionally
indented from the left margin using up to three spaces);&lt;/li&gt;
&lt;li&gt;followed by a colon;&lt;/li&gt;
&lt;li&gt;followed by one or more spaces (or tabs);&lt;/li&gt;
&lt;li&gt;followed by the URL for the link;&lt;/li&gt;
&lt;li&gt;optionally followed by a title attribute for the link, enclosed
in double or single quotes, or enclosed in parentheses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following three link definitions are equivalent:&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;http://example.com/&quot; title=&quot;Optional Title Here&quot;&gt;foo&lt;/a&gt;: &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;  ‘Optional Title Here’&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; There is a known bug in Markdown.pl 1.0.1 which prevents
single quotes from being used to delimit link titles.&lt;/p&gt;
&lt;p&gt;The link URL may, optionally, be surrounded by angle brackets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: &amp;lt;http://example.com/&amp;gt;  &amp;quot;Optional Title Here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can put the title attribute on the next line and use extra spaces
or tabs for padding, which tends to look better with longer URLs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: http://example.com/longish/path/to/resource/here
    &amp;quot;Optional Title Here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Link definitions are only used for creating links during Markdown
processing, and are stripped from your document in the HTML output.&lt;/p&gt;
&lt;p&gt;Link definition names may consist of letters, numbers, spaces, and
punctuation – but they are &lt;em&gt;not&lt;/em&gt; case sensitive. E.g. these two
links:&lt;/p&gt;
&lt;p&gt;  [link text][a]
  [link text][A]&lt;/p&gt;
&lt;p&gt;are equivalent.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;implicit link name&lt;/em&gt; shortcut allows you to omit the name of the
link, in which case the link text itself is used as the name.
Just use an empty set of square brackets – e.g., to link the word
“Google” to the google.com web site, you could simply write:&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;http://google.com/&quot;&gt;Google&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And then define the link:&lt;/p&gt;
&lt;p&gt;Because link names may contain spaces, this shortcut even works for
multiple words in the link text:&lt;/p&gt;
&lt;p&gt;  Visit &lt;a href=&quot;http://daringfireball.net/&quot;&gt;Daring Fireball&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;And then define the link:&lt;/p&gt;
&lt;p&gt;Link definitions can be placed anywhere in your Markdown document. I
tend to put them immediately after each paragraph in which they’re
used, but if you want, you can put them all at the end of your
document, sort of like footnotes.&lt;/p&gt;
&lt;p&gt;Here’s an example of reference links in action:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &amp;quot;Google&amp;quot;
  [2]: http://search.yahoo.com/  &amp;quot;Yahoo Search&amp;quot;
  [3]: http://search.msn.com/    &amp;quot;MSN Search&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using the implicit link name shortcut, you could instead write:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &amp;quot;Google&amp;quot;
  [yahoo]:  http://search.yahoo.com/  &amp;quot;Yahoo Search&amp;quot;
  [msn]:    http://search.msn.com/    &amp;quot;MSN Search&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both of the above examples will produce the following HTML output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&amp;quot;http://google.com/&amp;quot;
title=&amp;quot;Google&amp;quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from
&amp;lt;a href=&amp;quot;http://search.yahoo.com/&amp;quot; title=&amp;quot;Yahoo Search&amp;quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt;
or &amp;lt;a href=&amp;quot;http://search.msn.com/&amp;quot; title=&amp;quot;MSN Search&amp;quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For comparison, here is the same paragraph written using
Markdown’s inline link style:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I get 10 times more traffic from [Google](http://google.com/ &amp;quot;Google&amp;quot;)
than from [Yahoo](http://search.yahoo.com/ &amp;quot;Yahoo Search&amp;quot;) or
[MSN](http://search.msn.com/ &amp;quot;MSN Search&amp;quot;).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The point of reference-style links is not that they’re easier to
write. The point is that with reference-style links, your document
source is vastly more readable. Compare the above examples: using
reference-style links, the paragraph itself is only 81 characters
long; with inline-style links, it’s 176 characters; and as raw HTML,
it’s 234 characters. In the raw HTML, there’s more markup than there
is text.&lt;/p&gt;
&lt;p&gt;With Markdown’s reference-style links, a source document much more
closely resembles the final output, as rendered in a browser. By
allowing you to move the markup-related metadata out of the paragraph,
you can add links without interrupting the narrative flow of your
prose.&lt;/p&gt;
&lt;h3 id=&quot;em&quot;&gt;Emphasis&lt;/h3&gt;

&lt;p&gt;Markdown treats asterisks (&lt;code&gt;*&lt;/code&gt;) and underscores (&lt;code&gt;_&lt;/code&gt;) as indicators of
emphasis. Text wrapped with one &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; will be wrapped with an
HTML &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; tag; double &lt;code&gt;*&lt;/code&gt;‘s or &lt;code&gt;_&lt;/code&gt;‘s will be wrapped with an HTML
&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; tag. E.g., this input:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;will produce:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;em&amp;gt;single asterisks&amp;lt;/em&amp;gt;

&amp;lt;em&amp;gt;single underscores&amp;lt;/em&amp;gt;

&amp;lt;strong&amp;gt;double asterisks&amp;lt;/strong&amp;gt;

&amp;lt;strong&amp;gt;double underscores&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can use whichever style you prefer; the lone restriction is that
the same character must be used to open and close an emphasis span.&lt;/p&gt;
&lt;p&gt;Emphasis can be used in the middle of a word:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;un*frigging*believable
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But if you surround an &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt; with spaces, it’ll be treated as a
literal asterisk or underscore.&lt;/p&gt;
&lt;p&gt;To produce a literal asterisk or underscore at a position where it
would otherwise be used as an emphasis delimiter, you can backslash
escape it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\*this text is surrounded by literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;To indicate a span of code, wrap it with backtick quotes (&lt;code&gt;` &lt;/code&gt;).
Unlike a pre-formatted code block, a code span indicates code within a
normal paragraph. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Use the `printf()` function.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;will produce:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Use the &amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt; function.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To include a literal backtick character within a code span, you can use
multiple backticks as the opening and closing delimiters:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;``There is a literal backtick (`) here.``
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which will produce this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;There is a literal backtick (`) here.&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The backtick delimiters surrounding a code span may include spaces –
one after the opening, one before the closing. This allows you to place
literal backtick characters at the beginning or end of a code span:&lt;/p&gt;
&lt;p&gt;  A single backtick in a code span: &lt;code&gt;` &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  A backtick-delimited string in a code span: &lt;code&gt;`foo` &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;will produce:&lt;/p&gt;
  &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;&lt;code&gt;foo&lt;/code&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With a code span, ampersands and angle brackets are encoded as HTML
entities automatically, which makes it easy to include example HTML
tags. Markdown will turn this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please don&amp;#39;t use any `&amp;lt;blink&amp;gt;` tags.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;into:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Please don&amp;#39;t use any &amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can write this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`&amp;amp;#8212;` is the decimal-encoded equivalent of `&amp;amp;mdash;`.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to produce:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt; is the decimal-encoded
equivalent of &amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;img&quot;&gt;Images&lt;/h3&gt;

&lt;p&gt;Admittedly, it’s fairly difficult to devise a “natural” syntax for
placing images into a plain text document format.&lt;/p&gt;
&lt;p&gt;Markdown uses an image syntax that is intended to resemble the syntax
for links, allowing for two styles: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;reference&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Inline image syntax looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &amp;quot;Optional title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An exclamation mark: &lt;code&gt;!&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;followed by a set of square brackets, containing the &lt;code&gt;alt&lt;/code&gt;
attribute text for the image;&lt;/li&gt;
&lt;li&gt;followed by a set of parentheses, containing the URL or path to
the image, and an optional &lt;code&gt;title&lt;/code&gt; attribute enclosed in double
or single quotes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reference-style image syntax looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![Alt text][id]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where “id” is the name of a defined image reference. Image references
are defined using syntax identical to link references:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[id]: url/to/image  &amp;quot;Optional title attribute&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As of this writing, Markdown has no syntax for specifying the
dimensions of an image; if this is important to you, you can simply
use regular HTML &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;misc&quot;&gt;Miscellaneous&lt;/h2&gt;

&lt;h3 id=&quot;autolink&quot;&gt;Automatic Links&lt;/h3&gt;

&lt;p&gt;Markdown supports a shortcut style for creating “automatic” links for URLs and email addresses: simply surround the URL or email address with angle brackets. What this means is that if you want to show the actual text of a URL or email address, and also have it be a clickable link, you can do this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://example.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown will turn this into:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot;&amp;gt;http://example.com/&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Automatic links for email addresses work similarly, except that
Markdown will also perform a bit of randomized decimal and hex
entity-encoding to help obscure your address from address-harvesting
spambots. For example, Markdown will turn this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;address@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;into something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;amp;#x6D;&amp;amp;#x61;i&amp;amp;#x6C;&amp;amp;#x74;&amp;amp;#x6F;:&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;
&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;
&amp;amp;#109;&amp;quot;&amp;gt;&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;
&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;&amp;amp;#109;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which will render in a browser as a clickable link to “address@example.com”.&lt;/p&gt;
&lt;p&gt;(This sort of entity-encoding trick will indeed fool many, if not
most, address-harvesting bots, but it definitely won’t fool all of
them. It’s better than nothing, but an address published in this way
will probably eventually start receiving spam.)&lt;/p&gt;
&lt;h3 id=&quot;backslash&quot;&gt;Backslash Escapes&lt;/h3&gt;

&lt;p&gt;Markdown allows you to use backslash escapes to generate literal
characters which would otherwise have special meaning in Markdown’s
formatting syntax. For example, if you wanted to surround a word
with literal asterisks (instead of an HTML &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; tag), you can use
backslashes before the asterisks, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\*literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Markdown provides backslash escapes for the following characters:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\   backslash
`   backtick
*   asterisk
_   underscore
{}  curly braces
[]  square brackets
()  parentheses
#   hash mark
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;plus sign&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;minus sign (hyphen)
.   dot
!   exclamation mark&lt;/li&gt;
&lt;/ul&gt;
</description></item></channel></rss>